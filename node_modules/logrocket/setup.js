(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./packages/@logrocket/arson/src/index.js":
/*!************************************************!*\
  !*** ./packages/@logrocket/arson/src/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.encode = encode;
exports.decode = decode;
var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));
/* eslint-disable */

var UNDEFINED_INDEX = -1;
var ARRAY_HOLE_INDEX = -2;
var NAN_INDEX = -3;
var POS_INF_INDEX = -4;
var NEG_INF_INDEX = -5;
var customTypes = Object.create(null);
var registerType = function registerType(typeName, handlers) {
  function check(methodName) {
    if (typeof handlers[methodName] !== "function") {
      throw new Error("second argument to ARSON.registerType(" + JSON.stringify(typeName) + ", ...) " + "must be an object with a " + methodName + " method");
    }
  }
  check("deconstruct");
  check("reconstruct");
  customTypes[typeName] = handlers;
};
var toString = Object.prototype.toString;
var dateTag = "[object Date]";
var regExpTag = "[object RegExp]";
var setTag = "[object Set]";
var mapTag = "[object Map]";
typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && registerType("Buffer", {
  deconstruct: function deconstruct(buf) {
    return Buffer.isBuffer(buf) && [buf.toString("base64"), "base64"];
  },
  // The reconstruct function will be called twice: once with no
  // arguments, which allows it to return a placeholder object reference;
  // and once with one argument, a copy of the array returned by the
  // deconstruct function. For immutable types like Buffer, Date, and
  // RegExp, the reconstruct function should return a falsy value when it
  // receives no arguments, since there is no way to create an empty
  // Buffer or Date and later fill in its contents.  For container types
  // like Map and Set, the reconstruct function must return an empty
  // instance of the container when it receives no arguments, so that we
  // can fill in that empty container later. This two-phased strategy is
  // essential for decoding containers that contain themselves.
  reconstruct: function reconstruct(args) {
    return args && Buffer.from(args[0], args[1]);
  }
});
registerType("Date", {
  deconstruct: function deconstruct(date) {
    return toString.call(date) === dateTag && [date.toJSON()];
  },
  reconstruct: function reconstruct(args) {
    return args && new Date(args[0]);
  }
});
registerType("RegExp", {
  deconstruct: function deconstruct(exp) {
    if (toString.call(exp) === regExpTag) {
      var args = [exp.source];
      var flags = "";
      if (exp.ignoreCase) flags += "i";
      if (exp.multiline) flags += "m";
      if (exp.global) flags += "g";
      if (flags) {
        args.push(flags);
      }
      return args;
    }
  },
  reconstruct: function reconstruct(args) {
    return args && new RegExp(args[0], args[1]);
  }
});
typeof Set === "function" && typeof Array.from === "function" && registerType("Set", {
  deconstruct: function deconstruct(set) {
    if (toString.call(set) === setTag) {
      return Array.from(set);
    }
  },
  reconstruct: function reconstruct(values) {
    if (values) {
      values.forEach(this.add, this);
    } else {
      return new Set();
    }
  }
});
typeof Map === "function" && typeof Array.from === "function" && registerType("Map", {
  deconstruct: function deconstruct(map) {
    if (toString.call(map) === mapTag) {
      return Array.from(map);
    }
  },
  reconstruct: function reconstruct(entries) {
    if (entries) {
      entries.forEach(function (entry) {
        this.set(entry[0], entry[1]);
      }, this);
    } else {
      return new Map();
    }
  }
});
function encode(value) {
  return JSON.stringify(toTable(value));
}
function toTable(value) {
  var values = [];
  var indexMap = typeof Map === "function" && new Map();
  function getIndex(value) {
    switch ((0, _typeof2.default)(value)) {
      case "undefined":
        return UNDEFINED_INDEX;
      case "number":
        if (isNaN(value)) {
          return NAN_INDEX;
        }
        if (!isFinite(value)) {
          return value < 0 ? NEG_INF_INDEX : POS_INF_INDEX;
        }

      // fall through...
    }

    var index;
    if (indexMap) {
      // If we have Map, use it instead of values.indexOf to accelerate
      // object lookups.
      index = indexMap.get(value);
      if (typeof index === "undefined") {
        index = values.push(value) - 1;
        indexMap.set(value, index);
      }
    } else {
      index = values.indexOf(value);
      if (index < 0) {
        index = values.push(value) - 1;
      }
    }
    return index;
  }
  function copy(value) {
    var result = value;
    if (value && (0, _typeof2.default)(value) === "object") {
      var keys = Object.keys(value);
      if (isPlainObject(value)) {
        result = {};
      } else if (Array.isArray(value)) {
        result = Array(value.length);
        var len = value.length;
        if (len > keys.length) {
          // The array has holes, so make sure we fill them with the
          // ARRAY_HOLE_INDEX constant.
          for (var i = 0; i < len; ++i) {
            result[i] = ARRAY_HOLE_INDEX;
          }
        }
      } else {
        for (var typeName in customTypes) {
          // If value is not a plain Object, but something exotic like a
          // Date or a RegExp, serialize it as an array with typeName as
          // its first element. These arrays can be distinguished from
          // normal arrays, because all other non-empty arrays will be
          // serialized with a numeric value as their first element.
          var args = customTypes[typeName].deconstruct(value);
          if (args) {
            for (var i = 0; i < args.length; ++i) {
              args[i] = getIndex(args[i]);
            }
            args.unshift(typeName);
            return args;
          }
        }
        return {}.toString.call(value);
      }
      keys.forEach(function (key) {
        result[key] = getIndex(value[key]);
      });
    }
    return result;
  }

  // Assigns the root value to values[0].
  var index0 = getIndex(value);
  if (index0 < 0) {
    // If value is something special that gets a negative index, then we
    // don't need to build a table at all, and we can simply return that
    // negative index as a complete serialization. This avoids ambiguity
    // about indexes versus primitive literal values.
    return index0;
  }

  // Note that this for loop cannot be a forEach loop, because
  // values.length is expected to change during iteration.
  for (var table = [], v = 0; v < values.length; ++v) {
    table[v] = copy(values[v]);
  }
  return table;
}
function isPlainObject(value) {
  var isObject = value && (0, _typeof2.default)(value) === "object";
  if (isObject) {
    var proto = Object.getPrototypeOf ? Object.getPrototypeOf(value) : value.__proto__;
    return proto === Object.prototype;
  }
  return false;
}
function decode(encoding) {
  return fromTable(JSON.parse(encoding));
}
function fromTable(table) {
  if (typeof table === "number" && table < 0) {
    return getValueWithoutCache(table);
  }
  var getValueCache = new Array(table.length);
  function getValue(index) {
    return index in getValueCache ? getValueCache[index] : getValueCache[index] = getValueWithoutCache(index);
  }
  function getValueWithoutCache(index) {
    if (index < 0) {
      if (index === UNDEFINED_INDEX) {
        return;
      }
      if (index === ARRAY_HOLE_INDEX) {
        // Never reached because handled specially below.
        return;
      }
      if (index === NAN_INDEX) {
        return NaN;
      }
      if (index === POS_INF_INDEX) {
        return Infinity;
      }
      if (index === NEG_INF_INDEX) {
        return -Infinity;
      }
      throw new Error("invalid ARSON index: " + index);
    }
    var entry = table[index];
    if (entry && (0, _typeof2.default)(entry) === "object") {
      if (Array.isArray(entry)) {
        var elem0 = entry[0];
        if (typeof elem0 === "string" && elem0 in customTypes) {
          var rec = customTypes[elem0].reconstruct;
          var empty = rec();
          if (empty) {
            // If the reconstruct handler returns an object, treat it as
            // an empty instance of the desired type, and schedule it to
            // be filled in later. This two-stage process allows exotic
            // container objects to contain themselves.
            containers.push({
              reconstruct: rec,
              empty: empty,
              argIndexes: entry.slice(1)
            });
          }

          // If the reconstruct handler returned a falsy value, then we
          // assume none of its arguments refer to exotic containers, so
          // we can reconstruct the object immediately. Examples: Buffer,
          // Date, RegExp.
          return table[index] = empty || rec(entry.slice(1).map(getValue));
        }
      }

      // Here entry is already the correct array or object reference for
      // this index, but its values are still indexes that will need to be
      // resolved later.
      objects.push(entry);
    }
    return entry;
  }
  var containers = [];
  var objects = [];

  // First pass: make sure all exotic objects are deserialized fist, and
  // keep track of all plain object entries for later.
  table.forEach(function (entry, i) {
    getValue(i);
  });

  // Second pass: now that we have final object references for all exotic
  // objects, we can safely resolve argument indexes for the empty ones.
  containers.forEach(function (c) {
    c.args = c.argIndexes.map(getValue);
  });

  // Third pass: resolve value indexes for ordinary arrays and objects.
  objects.forEach(function (obj) {
    Object.keys(obj).forEach(function (key) {
      var index = obj[key];
      if (typeof index !== "number") {
        // Leave non-numeric indexes untouched.
        return;
      }
      if (index < 0) {
        if (index === ARRAY_HOLE_INDEX) {
          // Array holes have to be handled specially here, since getValue
          // does not have a reference to obj.
          delete obj[key];
          return;
        }

        // This recursion is guaranteed not to add more objects, because
        // we know the index is negative.
        obj[key] = getValue(index);
      } else {
        // Non-negative indexes refer to normal table values.
        obj[key] = table[index];
      }
    });
  });

  // Fourth pass: all possible object references have been established, so
  // we can finally initialize the empty container objects.
  containers.forEach(function (c) {
    c.reconstruct.call(c.empty, c.args);
  });
  return table[0];
}

/***/ }),

/***/ "./packages/@logrocket/console/src/index.js":
/*!**************************************************!*\
  !*** ./packages/@logrocket/console/src/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _registerConsole = _interopRequireDefault(__webpack_require__(/*! ./registerConsole */ "./packages/@logrocket/console/src/registerConsole.js"));
var _default = _registerConsole.default;
exports["default"] = _default;

/***/ }),

/***/ "./packages/@logrocket/console/src/registerConsole.js":
/*!************************************************************!*\
  !*** ./packages/@logrocket/console/src/registerConsole.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = registerConsole;
var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));
var _enhanceFunc = _interopRequireDefault(__webpack_require__(/*! @logrocket/utils/src/enhanceFunc */ "./packages/@logrocket/utils/src/enhanceFunc.js"));
var _exceptions = __webpack_require__(/*! @logrocket/exceptions */ "./packages/@logrocket/exceptions/src/index.js");
// eslint-disable-line no-restricted-imports

function registerConsole(logger) {
  var unsubFunctions = [];
  var methods = ['log', 'warn', 'info', 'error', 'debug'];
  methods.forEach(function (method) {
    unsubFunctions.push((0, _enhanceFunc.default)(console, method, function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      logger.addEvent('lr.core.LogEvent', function () {
        var consoleOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var isEnabled = consoleOptions.isEnabled;
        if ((0, _typeof2.default)(isEnabled) === 'object' && isEnabled[method] === false || isEnabled === false) {
          return null;
        }
        if (method === 'error' && consoleOptions.shouldAggregateConsoleErrors) {
          _exceptions.Capture.captureMessage(logger, args[0], args, {}, true);
        }
        return {
          logLevel: method.toUpperCase(),
          args: args
        };
      });
    }));
  });
  return function () {
    unsubFunctions.forEach(function (unsubFunction) {
      return unsubFunction();
    });
  };
}

/***/ }),

/***/ "./packages/@logrocket/exceptions/src/Capture.js":
/*!*******************************************************!*\
  !*** ./packages/@logrocket/exceptions/src/Capture.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.captureMessage = captureMessage;
exports.captureException = captureException;
var _utils = __webpack_require__(/*! @logrocket/utils */ "./packages/@logrocket/utils/src/index.ts");
var _TraceKit = _interopRequireDefault(__webpack_require__(/*! @logrocket/utils/src/TraceKit */ "./packages/@logrocket/utils/src/TraceKit.js"));
var _stackTraceFromError = _interopRequireDefault(__webpack_require__(/*! ./stackTraceFromError */ "./packages/@logrocket/exceptions/src/stackTraceFromError.js"));
// eslint-disable-line no-restricted-imports

function captureMessage(logger, message, messageArgs) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var isConsole = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var data = {
    exceptionType: isConsole ? 'CONSOLE' : 'MESSAGE',
    message: message,
    messageArgs: messageArgs,
    browserHref: window.location ? window.location.href : ''
  };
  (0, _utils.scrubException)(data, options);
  logger.addEvent('lr.core.Exception', function () {
    return data;
  });
}
function captureException(logger, exception) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var preppedTrace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var trace = preppedTrace || _TraceKit.default.computeStackTrace(exception);
  var data = {
    exceptionType: 'WINDOW',
    errorType: trace.name,
    message: trace.message,
    browserHref: window.location ? window.location.href : ''
  };
  (0, _utils.scrubException)(data, options);
  var addEventOptions = {
    _stackTrace: (0, _stackTraceFromError.default)(trace)
  };
  logger.addEvent('lr.core.Exception', function () {
    return data;
  }, addEventOptions);
}

/***/ }),

/***/ "./packages/@logrocket/exceptions/src/index.js":
/*!*****************************************************!*\
  !*** ./packages/@logrocket/exceptions/src/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "registerExceptions", ({
  enumerable: true,
  get: function get() {
    return _registerExceptions.default;
  }
}));
exports.Capture = void 0;
var _registerExceptions = _interopRequireDefault(__webpack_require__(/*! ./registerExceptions */ "./packages/@logrocket/exceptions/src/registerExceptions.js"));
var Capture = _interopRequireWildcard(__webpack_require__(/*! ./Capture */ "./packages/@logrocket/exceptions/src/Capture.js"));
exports.Capture = Capture;
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/***/ }),

/***/ "./packages/@logrocket/exceptions/src/raven/raven.js":
/*!***********************************************************!*\
  !*** ./packages/@logrocket/exceptions/src/raven/raven.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
var _TraceKit = _interopRequireDefault(__webpack_require__(/*! @logrocket/utils/src/TraceKit */ "./packages/@logrocket/utils/src/TraceKit.js"));
/* eslint-disable */

/*
Some contents of this file were originaly from raven-js, BSD-2 Clause

Copyright (c) 2018 Sentry (https://sentry.io) and individual contributors.
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var objectPrototype = Object.prototype;
function isUndefined(what) {
  return what === void 0;
}
function isFunction(what) {
  return typeof what === 'function';
}
function each(obj, callback) {
  var i, j;
  if (isUndefined(obj.length)) {
    for (i in obj) {
      if (hasKey(obj, i)) {
        callback.call(null, i, obj[i]);
      }
    }
  } else {
    j = obj.length;
    if (j) {
      for (i = 0; i < j; i++) {
        callback.call(null, i, obj[i]);
      }
    }
  }
}

/**
 * hasKey, a better form of hasOwnProperty
 * Example: hasKey(MainHostObject, property) === true/false
 *
 * @param {Object} host object to check property
 * @param {string} key to check
 */
function hasKey(object, key) {
  return objectPrototype.hasOwnProperty.call(object, key);
}

/**
 * Polyfill a method
 * @param obj object e.g. `document`
 * @param name method name present on object e.g. `addEventListener`
 * @param replacement replacement function
 * @param track {optional} record instrumentation to an array
 */
function fill(obj, name, replacement, track) {
  var orig = obj[name];
  obj[name] = replacement(orig);
  if (track) {
    track.push([obj, name, orig]);
  }
}
var _window = typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};
var _document = _window.document;
var Handler = /*#__PURE__*/function () {
  function Handler(_ref) {
    var captureException = _ref.captureException;
    (0, _classCallCheck2.default)(this, Handler);
    this._errorHandler = this._errorHandler.bind(this);
    this._ignoreOnError = 0;
    this._wrappedBuiltIns = [];
    this.captureException = captureException;
    _TraceKit.default.report.subscribe(this._errorHandler);
    this._instrumentTryCatch();
  }
  (0, _createClass2.default)(Handler, [{
    key: "uninstall",
    value: function uninstall() {
      _TraceKit.default.report.unsubscribe(this._errorHandler);

      // restore any wrapped builtins
      var builtin;
      while (this._wrappedBuiltIns.length) {
        builtin = this._wrappedBuiltIns.shift();
        var obj = builtin[0],
          name = builtin[1],
          orig = builtin[2];
        obj[name] = orig;
      }
    }
  }, {
    key: "_errorHandler",
    value: function _errorHandler(report) {
      if (!this._ignoreOnError) {
        this.captureException(report);
      }
    }
  }, {
    key: "_ignoreNextOnError",
    value: function _ignoreNextOnError() {
      var _this = this;
      this._ignoreOnError += 1;
      setTimeout(function () {
        // onerror should trigger before setTimeout
        _this._ignoreOnError -= 1;
      });
    }

    /*
     * Wrap code within a context so Handler can capture errors
     * reliably across domains that is executed immediately.
     *
     * @param {object} options A specific set of options for this context [optional]
     * @param {function} func The callback to be immediately executed within the context
     * @param {array} args An array of arguments to be called with the callback [optional]
     */
  }, {
    key: "context",
    value: function context(options, func, args) {
      if (isFunction(options)) {
        args = func || [];
        func = options;
        options = undefined;
      }
      return this.wrap(options, func).apply(this, args);
    }
  }, {
    key: "wrap",
    value:
    /*
     * Wrap code within a context and returns back a new function to be executed
     *
     * @param {object} options A specific set of options for this context [optional]
     * @param {function} func The function to be wrapped in a new context
     * @param {function} func A function to call before the try/catch wrapper [optional, private]
     * @return {function} The newly wrapped functions with a context
     */
    function wrap(options, func, _before) {
      var self = this;
      // 1 argument has been passed, and it's not a function
      // so just return it
      if (isUndefined(func) && !isFunction(options)) {
        return options;
      }

      // options is optional
      if (isFunction(options)) {
        func = options;
        options = undefined;
      }

      // At this point, we've passed along 2 arguments, and the second one
      // is not a function either, so we'll just return the second argument.
      if (!isFunction(func)) {
        return func;
      }

      // We don't wanna wrap it twice!
      try {
        if (func.__lr__) {
          return func;
        }

        // If this has already been wrapped in the past, return that
        if (func.__lr_wrapper__) {
          return func.__lr_wrapper__;
        }

        // If func is not extensible, return the function as-is to prevent TypeErrors
        // when trying to add new props & to assure immutable funcs aren't changed
        if (!Object.isExtensible(func)) {
          return func;
        }
      } catch (e) {
        // Just accessing custom props in some Selenium environments
        // can cause a "Permission denied" exception (see lr-js#495).
        // Bail on wrapping and return the function as-is (defers to window.onerror).
        return func;
      }
      function wrapped() {
        var args = [],
          i = arguments.length,
          deep = !options || options && options.deep !== false;
        if (_before && isFunction(_before)) {
          _before.apply(this, arguments);
        }

        // Recursively wrap all of a function's arguments that are
        // functions themselves.
        while (i--) {
          args[i] = deep ? self.wrap(options, arguments[i]) : arguments[i];
        }
        try {
          // Attempt to invoke user-land function. This is part of the LogRocket SDK.
          // If you're seeing this frame in a stack trace, it means that LogRocket caught
          // an unhandled error thrown by your application code, reported it, then bubbled
          // it up. This is expected behavior and is not a bug with LogRocket.
          return func.apply(this, args);
        } catch (e) {
          self._ignoreNextOnError();
          self.captureException(_TraceKit.default.computeStackTrace(e), options);
          throw e;
        }
      }

      // copy over properties of the old function
      for (var property in func) {
        if (hasKey(func, property)) {
          wrapped[property] = func[property];
        }
      }
      wrapped.prototype = func.prototype;
      func.__lr_wrapper__ = wrapped;
      // Signal that this function has been wrapped already
      // for both debugging and to prevent it to being wrapped twice
      wrapped.__lr__ = true;
      wrapped.__inner__ = func;
      return wrapped;
    }
  }, {
    key: "_instrumentTryCatch",
    value:
    /**
     * Install any queued plugins
     */
    function _instrumentTryCatch() {
      var self = this;
      var wrappedBuiltIns = self._wrappedBuiltIns;
      function wrapTimeFn(orig) {
        return function (fn, t) {
          // preserve arity
          // Make a copy of the arguments to prevent deoptimization
          // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; ++i) {
            args[i] = arguments[i];
          }
          var originalCallback = args[0];
          if (isFunction(originalCallback)) {
            args[0] = self.wrap(originalCallback);
          }

          // IE < 9 doesn't support .call/.apply on setInterval/setTimeout, but it
          // also supports only two arguments and doesn't care what this is, so we
          // can just call the original function directly.
          if (orig.apply) {
            return orig.apply(this, args);
          } else {
            return orig(args[0], args[1]);
          }
        };
      }
      function wrapEventTarget(global) {
        var proto = _window[global] && _window[global].prototype;
        if (proto && proto.hasOwnProperty && proto.hasOwnProperty('addEventListener')) {
          fill(proto, 'addEventListener', function (orig) {
            return function (evtName, fn, capture, secure) {
              // preserve arity
              try {
                if (fn && fn.handleEvent) {
                  fn.handleEvent = self.wrap(fn.handleEvent);
                }
              } catch (err) {
                // can sometimes get 'Permission denied to access property "handle Event'
              }

              // More breadcrumb DOM capture ... done here and not in `_instrumentBreadcrumbs`
              // so that we don't have more than one wrapper function
              var before;
              return orig.call(this, evtName, self.wrap(fn, undefined, before), capture, secure);
            };
          }, wrappedBuiltIns);
          fill(proto, 'removeEventListener', function (orig) {
            return function (evt, fn, capture, secure) {
              /**
               * There are 3 scenararios to consider when removing an event listener
               *
               * 1. 'addEventListener' was called when the LR SDK was uninitialized.
               * In this case, the event handler has not been wrapped, so this behaves 
               * as a passthrough and just removes the original handler.
               *
               * 2. 'addEventListener' was called while the LR SDK was initialized, which means
               * our wrapped 'addEventListener' was called. In this case, the tracked event handler
               * is also wrapped, so we need to remove that wrapped version of the handler.
               *
               * 3. 'addEventListener' was called both before and after the LR SDK was initialized
               * for the same event handler. In this case, we have to remove both of them.
               * If we'd remove only the wrapped one, the initial handler would stick around forever.
               */
              try {
                var wrappedFn = fn === null || fn === void 0 ? void 0 : fn.__lr_wrapper__;
                if (wrappedFn) {
                  orig.call(this, evt, wrappedFn, capture, secure);
                }
              } catch (e) {
                // ignore, accessing __lr_wrapper__ will throw in some Selenium environments
              }
              return orig.call(this, evt, fn, capture, secure);
            };
          },
          // undefined is provided here to skip tracking for uninstall.
          // Once our removeEventListener is installed, it can't be uninstalled.
          // We always need to support removing logrocket wrapped event handlers (event
          // handlers added when logrocket was installed) even after SDK shutdown.
          undefined);
        }
      }
      fill(_window, 'setTimeout', wrapTimeFn, wrappedBuiltIns);
      fill(_window, 'setInterval', wrapTimeFn, wrappedBuiltIns);
      if (_window.requestAnimationFrame) {
        fill(_window, 'requestAnimationFrame', function (orig) {
          return function (cb) {
            return orig(self.wrap(cb));
          };
        }, wrappedBuiltIns);
      }

      // event targets borrowed from bugsnag-js:
      // https://github.com/bugsnag/bugsnag-js/blob/master/src/bugsnag.js#L666
      var eventTargets = ['EventTarget', 'Window', 'Node', 'ApplicationCache', 'AudioTrackList', 'ChannelMergerNode', 'CryptoOperation', 'EventSource', 'FileReader', 'HTMLUnknownElement', 'IDBDatabase', 'IDBRequest', 'IDBTransaction', 'KeyOperation', 'MediaController', 'MessagePort', 'ModalWindow', 'Notification', 'SVGElementInstance', 'Screen', 'TextTrack', 'TextTrackCue', 'TextTrackList', 'WebSocket', 'WebSocketWorker', 'Worker', 'XMLHttpRequest', 'XMLHttpRequestEventTarget', 'XMLHttpRequestUpload'];
      for (var i = 0; i < eventTargets.length; i++) {
        wrapEventTarget(eventTargets[i]);
      }
      var $ = _window.jQuery || _window.$;
      if ($ && $.fn && $.fn.ready) {
        fill($.fn, 'ready', function (orig) {
          return function (fn) {
            return orig.call(this, self.wrap(fn));
          };
        }, wrappedBuiltIns);
      }
    }
  }]);
  return Handler;
}();
exports["default"] = Handler;
;

/***/ }),

/***/ "./packages/@logrocket/exceptions/src/registerExceptions.js":
/*!******************************************************************!*\
  !*** ./packages/@logrocket/exceptions/src/registerExceptions.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = registerCore;
var _raven = _interopRequireDefault(__webpack_require__(/*! ./raven/raven */ "./packages/@logrocket/exceptions/src/raven/raven.js"));
var Capture = _interopRequireWildcard(__webpack_require__(/*! ./Capture */ "./packages/@logrocket/exceptions/src/Capture.js"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function registerCore(logger) {
  var raven = new _raven.default({
    captureException: function captureException(errorReport) {
      Capture.captureException(logger, null, null, errorReport);
    }
  });
  var rejectionHandler = function rejectionHandler(evt) {
    // http://2ality.com/2016/04/unhandled-rejections.html
    logger.addEvent('lr.core.Exception', function () {
      return {
        exceptionType: 'UNHANDLED_REJECTION',
        message: evt.reason || 'Unhandled Promise rejection'
      };
    });
  };
  window.addEventListener('unhandledrejection', rejectionHandler);
  return function () {
    window.removeEventListener('unhandledrejection', rejectionHandler);
    raven.uninstall();
  };
}

/***/ }),

/***/ "./packages/@logrocket/exceptions/src/stackTraceFromError.js":
/*!*******************************************************************!*\
  !*** ./packages/@logrocket/exceptions/src/stackTraceFromError.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = stackTraceFromError;
function stackTraceFromError(errorReport) {
  function makeNotNull(val) {
    return val === null ? undefined : val;
  }
  return errorReport.stack ? errorReport.stack.map(function (frame) {
    return {
      lineNumber: makeNotNull(frame.line),
      columnNumber: makeNotNull(frame.column),
      fileName: makeNotNull(frame.url),
      functionName: makeNotNull(frame.func)
    };
  }) : undefined;
}

/***/ }),

/***/ "./packages/@logrocket/network/src/fetchIntercept.js":
/*!***********************************************************!*\
  !*** ./packages/@logrocket/network/src/fetchIntercept.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js"));
var _registerXHR = __webpack_require__(/*! ./registerXHR */ "./packages/@logrocket/network/src/registerXHR.js");
var interceptors = [];
function makeInterceptor(fetch, fetchId) {
  var reversedInterceptors = interceptors.reduce(function (array, interceptor) {
    return [interceptor].concat(array);
  }, []);
  // if a browser supports fetch, it supports promise
  // eslint-disable-next-line compat/compat
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  var promise = Promise.resolve(args);

  // Register request interceptors
  reversedInterceptors.forEach(function (_ref) {
    var request = _ref.request,
      requestError = _ref.requestError;
    if (request || requestError) {
      promise = promise.then(function (args) {
        return request.apply(void 0, [fetchId].concat((0, _toConsumableArray2.default)(args)));
      }, function (args) {
        return requestError.apply(void 0, [fetchId].concat((0, _toConsumableArray2.default)(args)));
      });
    }
  });
  promise = promise.then(function (args) {
    (0, _registerXHR.setActive)(false);
    var res;
    var err;
    try {
      res = fetch.apply(void 0, (0, _toConsumableArray2.default)(args));
    } catch (_err) {
      err = _err;
    }
    (0, _registerXHR.setActive)(true);
    if (err) {
      throw err;
    }
    return res;
  });
  reversedInterceptors.forEach(function (_ref2) {
    var response = _ref2.response,
      responseError = _ref2.responseError;
    if (response || responseError) {
      promise = promise.then(function (res) {
        return response(fetchId, res);
      }, function (err) {
        return responseError && responseError(fetchId, err);
      });
    }
  });
  return promise;
}
function attach(env) {
  if (!env.fetch || !env.Promise) {
    // Make sure fetch is available in the given environment. If it's not, then
    // default to using XHR intercept.
    return;
  }
  var isPolyfill = env.fetch.polyfill;

  // eslint-disable-next-line no-param-reassign
  env.fetch = function (fetch) {
    var fetchId = 0;
    return function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return makeInterceptor.apply(void 0, [fetch, fetchId++].concat(args));
    };
  }(env.fetch);

  // Forward the polyfill properly from fetch (set by github/whatwg-fetch).
  if (isPolyfill) {
    // eslint-disable-next-line no-param-reassign
    env.fetch.polyfill = isPolyfill;
  }
}

// TODO: React Native
//   attach(global);

var didAttach = false;
var _default = {
  register: function register(interceptor) {
    if (!didAttach) {
      didAttach = true;
      attach(window);
    }
    interceptors.push(interceptor);
    return function () {
      var index = interceptors.indexOf(interceptor);
      if (index >= 0) {
        interceptors.splice(index, 1);
      }
    };
  },
  clear: function clear() {
    interceptors = [];
  }
};
exports["default"] = _default;

/***/ }),

/***/ "./packages/@logrocket/network/src/index.js":
/*!**************************************************!*\
  !*** ./packages/@logrocket/network/src/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = registerNetwork;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));
var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));
var _registerFetch = _interopRequireDefault(__webpack_require__(/*! ./registerFetch */ "./packages/@logrocket/network/src/registerFetch.js"));
var _registerIonic = __webpack_require__(/*! ./registerIonic */ "./packages/@logrocket/network/src/registerIonic.ts");
var _registerNetworkInformation = _interopRequireDefault(__webpack_require__(/*! ./registerNetworkInformation */ "./packages/@logrocket/network/src/registerNetworkInformation.js"));
var _registerXHR = _interopRequireDefault(__webpack_require__(/*! ./registerXHR */ "./packages/@logrocket/network/src/registerXHR.js"));
var _mapValues = _interopRequireDefault(__webpack_require__(/*! @logrocket/utils/src/mapValues */ "./packages/@logrocket/utils/src/mapValues.js"));
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
// eslint-disable-line no-restricted-imports

function registerNetwork(logger) {
  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    isReactNative: false
  };
  var isReactNative = config.isReactNative,
    shouldAugmentNPS = config.shouldAugmentNPS,
    shouldParseXHRBlob = config.shouldParseXHRBlob;
  var ignoredNetwork = {};

  // truncate if > 4MB in size
  var truncate = function truncate(data) {
    var limit = 1024 * 1000 * 4;
    var str = data;
    if ((0, _typeof2.default)(data) === 'object' && data != null) {
      var proto = Object.getPrototypeOf(data);
      if (proto === Object.prototype || proto === null) {
        // plain object - jsonify for the size check
        str = JSON.stringify(data);
      }
    }
    if (str && str.length && str.length > limit && typeof str === 'string') {
      var beginning = str.substring(0, 1000);
      return "".concat(beginning, " ... LogRocket truncating to first 1000 characters.\n      Keep data under 4MB to prevent truncation. https://docs.logrocket.com/reference/network");
    }
    return data;
  };
  var addRequest = function addRequest(reqId, request) {
    var method = request.method;
    logger.addEvent('lr.network.RequestEvent', function () {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$isEnabled = _ref.isEnabled,
        isEnabled = _ref$isEnabled === void 0 ? true : _ref$isEnabled,
        _ref$requestSanitizer = _ref.requestSanitizer,
        requestSanitizer = _ref$requestSanitizer === void 0 ? function (f) {
          return f;
        } : _ref$requestSanitizer;
      if (!isEnabled) {
        return null;
      }
      var sanitized = null;
      try {
        // only try catch user defined functions
        sanitized = requestSanitizer(_objectSpread(_objectSpread({}, request), {}, {
          reqId: reqId
        }));
      } catch (err) {
        console.error(err);
      }
      if (sanitized) {
        var url = sanitized.url;
        if (typeof document !== 'undefined' && typeof document.createElement === 'function') {
          // Writing and then reading from an a tag turns a relative
          // url into an absolute one.
          var a = document.createElement('a');
          a.href = sanitized.url;
          url = a.href;
        }
        return {
          reqId: reqId,
          // default
          url: url,
          // sanitized
          headers: (0, _mapValues.default)(sanitized.headers, function (headerValue) {
            // sanitized
            return "".concat(headerValue);
          }),
          body: truncate(sanitized.body),
          // sanitized
          method: method,
          // default
          referrer: sanitized.referrer || undefined,
          // sanitized
          mode: sanitized.mode || undefined,
          // sanitized
          credentials: sanitized.credentials || undefined // sanitized
        };
      }

      ignoredNetwork[reqId] = true;
      return null;
    });
  };
  var addResponse = function addResponse(reqId, response) {
    var method = response.method,
      status = response.status;
    logger.addEvent('lr.network.ResponseEvent', function () {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$isEnabled = _ref2.isEnabled,
        isEnabled = _ref2$isEnabled === void 0 ? true : _ref2$isEnabled,
        _ref2$responseSanitiz = _ref2.responseSanitizer,
        responseSanitizer = _ref2$responseSanitiz === void 0 ? function (f) {
          return f;
        } : _ref2$responseSanitiz;
      if (!isEnabled) {
        return null;
      } else if (ignoredNetwork[reqId]) {
        delete ignoredNetwork[reqId];
        return null;
      }
      var sanitized = null;
      try {
        // only try catch user defined functions
        sanitized = responseSanitizer(_objectSpread(_objectSpread({}, response), {}, {
          reqId: reqId
        }));
      } catch (err) {
        console.error(err);
        // fall through to redacted log
      }

      if (sanitized) {
        return {
          reqId: reqId,
          // default
          status: sanitized.status,
          // sanitized
          headers: (0, _mapValues.default)(sanitized.headers, function (headerValue) {
            // sanitized
            return "".concat(headerValue);
          }),
          body: truncate(sanitized.body),
          // sanitized
          method: method // default
        };
      }

      return {
        reqId: reqId,
        // default
        status: status,
        // default
        headers: {},
        // redacted
        body: null,
        // redacted
        method: method // default
      };
    });
  };

  var isIgnored = function isIgnored(reqId) {
    return logger.isDisabled || ignoredNetwork[reqId] === true;
  };
  var unsubFetch = (0, _registerFetch.default)({
    addRequest: addRequest,
    addResponse: addResponse,
    isIgnored: isIgnored
  });
  var unsubXHR = (0, _registerXHR.default)({
    addRequest: addRequest,
    addResponse: addResponse,
    isIgnored: isIgnored,
    logger: logger,
    shouldAugmentNPS: shouldAugmentNPS,
    shouldParseXHRBlob: shouldParseXHRBlob
  });
  var unsubIonic = (0, _registerIonic.registerIonic)({
    addRequest: addRequest,
    addResponse: addResponse,
    isIgnored: isIgnored
  });
  var unsubNetworkInformation = isReactNative ? function () {} : (0, _registerNetworkInformation.default)(logger);
  return function () {
    unsubNetworkInformation();
    unsubFetch();
    unsubXHR();
    unsubIonic();
  };
}

/***/ }),

/***/ "./packages/@logrocket/network/src/registerFetch.js":
/*!**********************************************************!*\
  !*** ./packages/@logrocket/network/src/registerFetch.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = registerFetch;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));
var _mapValues = _interopRequireDefault(__webpack_require__(/*! @logrocket/utils/src/mapValues */ "./packages/@logrocket/utils/src/mapValues.js"));
var _fetchIntercept = _interopRequireDefault(__webpack_require__(/*! ./fetchIntercept */ "./packages/@logrocket/network/src/fetchIntercept.js"));
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function makeObjectFromHeaders(headers) {
  // If using real fetch, we must stringify the Headers object.
  if (headers == null || typeof headers.forEach !== 'function') {
    return headers;
  }
  var result = {};
  headers.forEach(function (value, key) {
    if (result[key]) {
      result[key] = "".concat(result[key], ",").concat(value);
    } else {
      result[key] = "".concat(value);
    }
  });
  return result;
}

// XHR specification is unclear of what types to allow in value so using toString method for now
var stringifyHeaders = function stringifyHeaders(headers) {
  return (0, _mapValues.default)(makeObjectFromHeaders(headers), function (value) {
    return "".concat(value);
  });
};
function pluckFetchFields() {
  var arg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    url: arg.url,
    headers: stringifyHeaders(arg.headers),
    method: arg.method && arg.method.toUpperCase(),
    referrer: arg.referrer || undefined,
    mode: arg.mode || undefined,
    credentials: arg.credentials || undefined
  };
}
function registerFetch(_ref) {
  var addRequest = _ref.addRequest,
    addResponse = _ref.addResponse,
    isIgnored = _ref.isIgnored;
  var LOGROCKET_FETCH_LABEL = 'fetch-';
  var fetchMethodMap = {};
  var unregister = _fetchIntercept.default.register({
    request: function request(fetchId) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var p;
      if (typeof Request !== 'undefined' && args[0] instanceof Request) {
        var clonedText;

        // Request.clone() and Request.text() may throw in Safari (e.g., when
        // request body contains FormData)
        try {
          clonedText = args[0].clone().text();
        } catch (err) {
          // if a browser supports fetch, it supports promise
          // eslint-disable-next-line compat/compat
          clonedText = Promise.resolve("LogRocket fetch error: ".concat(err.message));
        }
        p = clonedText.then(function (body) {
          return _objectSpread(_objectSpread({}, pluckFetchFields(args[0])), {}, {
            body: body
          });
        }, function (err) {
          return _objectSpread(_objectSpread({}, pluckFetchFields(args[0])), {}, {
            body: "LogRocket fetch error: ".concat(err.message)
          });
        });
      } else {
        // if a browser supports fetch, it supports promise
        // eslint-disable-next-line compat/compat
        p = Promise.resolve(_objectSpread(_objectSpread({}, pluckFetchFields(args[1])), {}, {
          url: "".concat(args[0]),
          body: (args[1] || {}).body
        }));
      }
      return p.then(function (req) {
        fetchMethodMap[fetchId] = req.method;
        addRequest("".concat(LOGROCKET_FETCH_LABEL).concat(fetchId), req);
        return args;
      });
    },
    requestError: function requestError(fetchId, error) {
      // if a browser supports fetch, it supports promise
      // eslint-disable-next-line compat/compat
      return Promise.reject(error);
    },
    response: function response(fetchId, _response) {
      var responseClone;
      var responseTextPromise;
      if (isIgnored("".concat(LOGROCKET_FETCH_LABEL).concat(fetchId))) {
        // Don't even try to read ignored requests
        return _response;
      }

      // event-streams are meant to remain open and be consumed over time by the sender. Attempting to capture the body
      // of these requests will cause us to "stall" here, and prevents the users of our SDK from using event-streams
      // unless they have explicitly ignored the request.
      if (_response.headers.get('content-type') === 'text/event-stream') {
        // eslint-disable-next-line compat/compat
        responseTextPromise = Promise.resolve('LogRocket skipped consuming an event-stream body.');
      } else {
        try {
          // TODO: enhance function on original response and future clones for:
          // text(), json(), blob(), formdata(), arraybuffer()
          responseClone = _response.clone();
        } catch (err) {
          // safari has a bug where cloning can fail
          var responseHash = {
            url: _response.url,
            status: _response.status,
            headers: stringifyHeaders(_response.headers),
            body: "LogRocket fetch error: ".concat(err.message),
            method: fetchMethodMap[fetchId]
          };
          delete fetchMethodMap[fetchId];
          addResponse("".concat(LOGROCKET_FETCH_LABEL).concat(fetchId), responseHash);
          return _response;
        }
        try {
          if (window.TextDecoder && responseClone.body) {
            // use a reader to manually read the response body rather than calling response.text()
            // response.text() was timing out for some responses, in some cases because Apollo sends
            //   an abort signal or because the stream wasn't getting terminated cleanly
            // using a reader allows us to capture what we can from response bodies before the
            //   response receives an abort signal
            var reader = responseClone.body.getReader();
            // response bodies always decode with UTF-8
            // https://developer.mozilla.org/en-US/docs/Web/API/Response/text
            var utf8Decoder = new window.TextDecoder('utf-8');
            var bodyContents = '';
            responseTextPromise = reader.read().then(function readResponseBody(_ref2) {
              var done = _ref2.done,
                value = _ref2.value;
              if (done) {
                return bodyContents;
              }
              var chunk = value ? utf8Decoder.decode(value, {
                stream: true
              }) : '';
              bodyContents += chunk;
              return reader.read().then(readResponseBody);
            });
          } else {
            // TextDecoder doesn't have support across all browsers that LR supports, so if there's
            //  no TextDecoder, fall back to the old approach
            responseTextPromise = responseClone.text();
          }
        } catch (error) {
          // eslint-disable-next-line compat/compat
          responseTextPromise = Promise.resolve("LogRocket error reading body: ".concat(error.message));
        }
      }
      responseTextPromise.catch(function (error) {
        // don't drop request & log to console when the request is aborted,
        // as it may have already completed
        // https://github.com/LogRocket/logrocket/issues/34
        if (error.name === 'AbortError' && error instanceof DOMException) {
          return;
        }
        return "LogRocket error reading body: ".concat(error.message);
      }).then(function (data) {
        var responseHash = {
          url: _response.url,
          status: _response.status,
          headers: stringifyHeaders(_response.headers),
          body: data,
          method: fetchMethodMap[fetchId]
        };
        delete fetchMethodMap[fetchId];
        addResponse("".concat(LOGROCKET_FETCH_LABEL).concat(fetchId), responseHash);
      });
      return _response;
    },
    responseError: function responseError(fetchId, error) {
      var response = {
        url: undefined,
        status: 0,
        headers: {},
        body: "".concat(error)
      };
      addResponse("".concat(LOGROCKET_FETCH_LABEL).concat(fetchId), response);
      // if a browser supports fetch, it supports promise
      // eslint-disable-next-line compat/compat
      return Promise.reject(error);
    }
  });
  return unregister;
}

/***/ }),

/***/ "./packages/@logrocket/network/src/registerIonic.ts":
/*!**********************************************************!*\
  !*** ./packages/@logrocket/network/src/registerIonic.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.mergeHeaders = mergeHeaders;
exports.serializeQueryParams = serializeQueryParams;
exports.appendQueryParamsString = appendQueryParamsString;
exports.processData = processData;
exports.registerIonic = registerIonic;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));
var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));
var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js"));
var _protectFunc = _interopRequireDefault(__webpack_require__(/*! @logrocket/utils/src/protectFunc */ "./packages/@logrocket/utils/src/protectFunc.js"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var VALID_HTTP_METHODS = new Set(['get', 'put', 'post', 'patch', 'head', 'delete', 'options', 'upload', 'download']);
var VALID_SERIALIZERS = new Set(['urlencoded', 'json', 'utf8']);
var UNSUPPORTED_SERIALIZERS = new Set(['raw', 'multipart']);
var LOGROCKET_IONIC_LABEL = 'ionic-';
var UNSUPPORTED_PLATFORMS = new Set(['desktop', 'mobileweb', 'pwa']);
var FORM_DATA = new Set(['FormData']);
var EMPTY_SET = new Set();
var STRING_SET = new Set(['string']);
var STRING_ARRAY_SET = new Set(['string', 'array']);
var ALLOWED_DATA_TYPES = {
  utf8: STRING_SET,
  urlencoded: new Set(['object']),
  json: new Set(['array', 'object']),
  raw: new Set(['Uint8Array', 'ArrayBuffer']),
  default: EMPTY_SET
};

// Used in intercepting Ionic pugin requests found here https://www.npmjs.com/package/@ionic-native/http
// based on https://github.com/silkimen/cordova-plugin-advanced-http/blob/master/www/public-interface.js

function checkForValidStringValue(list, value, fieldName) {
  if (typeof value !== 'string') {
    throw new Error("".concat(fieldName, " must be one of: ").concat((0, _toConsumableArray2.default)(list).join(', ')));
  }

  // eslint-disable-next-line no-param-reassign
  value = value.trim().toLowerCase();
  if (!list.has(value)) {
    throw new Error("".concat(fieldName, " must be one of: ").concat((0, _toConsumableArray2.default)(list).join(', ')));
  }
  return value;
}
function checkKeyValuePairObject(obj, allowedChildren, onInvalidValueMessage) {
  if ((0, _typeof2.default)(obj) !== 'object') {
    throw new Error(onInvalidValueMessage);
  }
  for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    if (!allowedChildren.has((0, _typeof2.default)(obj[key]))) {
      throw new Error(onInvalidValueMessage);
    }
  }
  return obj;
}
function getMatchingHostHeaders(url, ionicHttp) {
  var _URL = new URL(url),
    host = _URL.host;
  return ionicHttp.getHeaders(host) || null;
}
function mergeHeaders(defaultHeaders, headers) {
  return _objectSpread(_objectSpread({}, defaultHeaders), headers);
}
function getMergedHeaders(url, requestHeaders, ionicHttp) {
  // get global headers via public method
  var globalHeaders = ionicHttp.getHeaders('*') || {};
  var hostHeaders = getMatchingHostHeaders(url, ionicHttp) || {};
  return mergeHeaders(mergeHeaders(globalHeaders, hostHeaders), requestHeaders);
}
function serializeValue(value, encode) {
  if (encode) {
    return encodeURIComponent(value);
  } else {
    return value;
  }
}
function serializeIdentifier(parentKey, key, encode) {
  if (!parentKey.length) {
    return encode ? encodeURIComponent(key) : key;
  }
  if (encode) {
    return "".concat(encodeURIComponent(parentKey), "[").concat(encodeURIComponent(key), "]");
  } else {
    return "".concat(parentKey, "[").concat(key, "]");
  }
}
function serializeArray(parentKey, array, encode) {
  var parts = [];
  var _iterator = _createForOfIteratorHelper(array),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var e = _step.value;
      if (Array.isArray(e)) {
        parts.push(serializeArray("".concat(parentKey, "[]"), e, encode));
        continue;
      } else if ((0, _typeof2.default)(e) === 'object') {
        /* This replicates what appears to be a bug in the Ionic code in order to capture everything identically
           parts.push(serializeObject(`${parentKey}[]${array[i]}`, encode));
           https://github.com/silkimen/cordova-plugin-advanced-http/blob/master/www/url-util.js#L73
        */
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        parts.push(serializeObject("".concat(parentKey, "[]").concat(e), encode, undefined));
        continue;
      }
      parts.push("".concat(serializeIdentifier(parentKey, '', encode), "=").concat(serializeValue(e, encode)));
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return parts.join('&');
}
function serializeObject(parentKey, object, encode) {
  var parts = [];
  for (var key in object) {
    if (!object.hasOwnProperty(key)) {
      continue;
    }
    var identifier = parentKey.length ? "".concat(parentKey, "[").concat(key, "]") : key;
    if (Array.isArray(object[key])) {
      parts.push(serializeArray(identifier, object[key], encode));
      continue;
    } else if ((0, _typeof2.default)(object[key]) === 'object' && object[key] !== null) {
      parts.push(serializeObject(identifier, object[key], encode));
      continue;
    }
    parts.push("".concat(serializeIdentifier(parentKey, key, encode), "=").concat(serializeValue(object[key], encode)));
  }
  return parts.join('&');
}
function serializeQueryParams(params, encode) {
  return serializeObject('', params, encode);
}
function appendQueryParamsString(url, params) {
  if (!url.length || !params.length) {
    return url;
  }
  var _URL2 = new URL(url),
    host = _URL2.host,
    pathname = _URL2.pathname,
    search = _URL2.search,
    hash = _URL2.hash,
    protocol = _URL2.protocol;
  return "".concat(protocol, "//").concat(host).concat(pathname).concat(search.length ? "".concat(search, "&").concat(params) : "?".concat(params)).concat(hash);
}
function getAllowedDataTypes(dataSerializer) {
  return ALLOWED_DATA_TYPES[dataSerializer] || ALLOWED_DATA_TYPES.default;
}
function getAllowedInstanceTypes(dataSerializer) {
  return dataSerializer === 'multipart' ? FORM_DATA : EMPTY_SET;
}
function processData(data, dataSerializer) {
  var currentDataType = (0, _typeof2.default)(data);
  var allowedDataTypes = getAllowedDataTypes(dataSerializer);
  var allowedInstanceTypes = getAllowedInstanceTypes(dataSerializer);
  if (allowedInstanceTypes.size > 0) {
    var isCorrectInstanceType = false;
    allowedInstanceTypes.forEach(function (type) {
      if (__webpack_require__.g[type] && data instanceof __webpack_require__.g[type]) {
        isCorrectInstanceType = true;
      }
    });
    if (!isCorrectInstanceType) {
      throw new Error("INSTANCE_TYPE_MISMATCH_DATA ".concat((0, _toConsumableArray2.default)(allowedInstanceTypes).join(', ')));
    }
  }
  if (allowedInstanceTypes.size === 0 && !allowedDataTypes.has(currentDataType)) {
    throw new Error("TYPE_MISMATCH_DATA ".concat((0, _toConsumableArray2.default)(allowedDataTypes).join(', ')));
  }
  switch (dataSerializer) {
    case 'utf8':
      // already a string
      return data;
    default:
      // object of some sort (urlencoded or json)
      return JSON.stringify(data, undefined, 2);
  }
}
function handleMissingOptions(options, ionicHttp) {
  // eslint-disable-next-line no-param-reassign
  options = options || {};
  var serializer;
  var data = options.data;
  try {
    // need to check special case if data type is not handled by LR but otherwise valid
    serializer = checkForValidStringValue(VALID_SERIALIZERS, options.serializer || ionicHttp.getDataSerializer(), 'serializer / data payload type');
  } catch (_unused) {
    // if this fails it's of entirely invalid type, let it fail
    serializer = checkForValidStringValue(UNSUPPORTED_SERIALIZERS, options.serializer || ionicHttp.getDataSerializer(), 'serializer / data payload type');
    // is of a valid but unsupported to LR type, set data to empty
    data = {};
  }
  return {
    data: data,
    filePath: options.filePath,
    followRedirect: options.followRedirect,
    headers: checkKeyValuePairObject(options.headers || {}, STRING_SET, 'Invalid header type, must be string'),
    method: checkForValidStringValue(VALID_HTTP_METHODS, options.method || VALID_HTTP_METHODS[0], 'method'),
    name: options.name,
    params: checkKeyValuePairObject(options.params || {}, STRING_ARRAY_SET, 'Invalid param, must be of type string or array'),
    responseType: options.responseType,
    serializer: serializer,
    connectTimeout: options.connectTimeout,
    readTimeout: options.readTimeout,
    timeout: options.timeout
  };
}
var ionicIdCounter = 0;
function registerIonic(_ref) {
  var _cordova, _cordova$plugin, _window$ionic;
  var addRequest = _ref.addRequest,
    addResponse = _ref.addResponse,
    isIgnored = _ref.isIgnored;
  var ionicHttp = (_cordova = window.cordova) === null || _cordova === void 0 ? void 0 : (_cordova$plugin = _cordova.plugin) === null || _cordova$plugin === void 0 ? void 0 : _cordova$plugin.http;
  var ionicMap = {};
  var unsubscribedFromIonic = false;
  if (typeof ionicHttp === 'undefined') {
    // Plugin does not exist! Empty uninstall hook.
    return function () {};
  }
  var platforms = (_window$ionic = window.ionic) === null || _window$ionic === void 0 ? void 0 : _window$ionic.platforms;
  if (typeof platforms !== 'undefined' && typeof platforms.some === 'function' && platforms.some(function (e) {
    return UNSUPPORTED_PLATFORMS.has(e);
  })) {
    // We appear to be running in a web browser, do not hook and let XHR wrap instead.
    return function () {};
  }
  var originalSendRequest = ionicHttp.sendRequest;
  var handleResponse = (0, _protectFunc.default)(function (response, isSuccess, ionicReqId) {
    if (!isIgnored("".concat(LOGROCKET_IONIC_LABEL).concat(ionicReqId))) {
      try {
        var responseHash = {
          url: response.url || '',
          status: response.status < 600 && response.status >= 100 ? response.status : 0,
          headers: response.headers || {},
          body: isSuccess ? response.data : response.error,
          method: ionicMap[ionicReqId].toUpperCase()
        };
        addResponse("".concat(LOGROCKET_IONIC_LABEL).concat(ionicReqId), responseHash);
      } catch (err) {
        var _responseHash = {
          url: response.url || '',
          status: response.status < 600 && response.status >= 100 ? response.status : 0,
          headers: response.headers || {},
          body: "LogRocket fetch error: ".concat(err.message),
          method: ionicMap[ionicReqId].toUpperCase()
        };
        addResponse("".concat(LOGROCKET_IONIC_LABEL).concat(ionicReqId), _responseHash);
      }
    } // Otherwise, don't even try to read ignored / unsubscribed requests
  });

  ionicHttp.sendRequest = function (url, options, success, failure) {
    var currentId = ++ionicIdCounter;
    var ourSuccessHandler = function ourSuccessHandler(response) {
      if (!unsubscribedFromIonic) {
        handleResponse(response, true, currentId);
        delete ionicMap[currentId];
      }
      success(response);
    };
    var ourFailureHandler = function ourFailureHandler(response) {
      if (!unsubscribedFromIonic) {
        handleResponse(response, false, currentId);
        delete ionicMap[currentId];
      }
      failure(response);
    };
    if (!unsubscribedFromIonic) {
      try {
        // will throw just like identical ionic code if input is invalid
        var modifiedOptions = handleMissingOptions(options, ionicHttp);
        var modifiedUrl = appendQueryParamsString(url, serializeObject('', modifiedOptions.params, true));
        // need to minic behavior of Ionic API by adding global headers
        var mergedHeaders = getMergedHeaders(url, modifiedOptions.headers, ionicHttp);

        // ionic APIs default to get method
        var method = modifiedOptions.method || 'get';
        ionicMap[currentId] = method;
        var requestHash = {
          url: modifiedUrl,
          method: method.toUpperCase(),
          headers: mergedHeaders || {},
          // only applicable on post, put or patch methods
          body: processData(modifiedOptions.data || {}, modifiedOptions.serializer)
        };
        addRequest("".concat(LOGROCKET_IONIC_LABEL).concat(currentId), requestHash);
      } catch (err) {
        var _requestHash = {
          url: url,
          method: (options.method || 'get').toUpperCase(),
          headers: {},
          body: "LogRocket fetch error: ".concat(err.message)
        };
        addRequest("".concat(LOGROCKET_IONIC_LABEL).concat(currentId), _requestHash);
      }
    }
    return originalSendRequest(url, options, ourSuccessHandler, ourFailureHandler);
  };
  return function () {
    unsubscribedFromIonic = true;
    ionicHttp.sendRequest = originalSendRequest;
    ionicMap = {};
  };
}

/***/ }),

/***/ "./packages/@logrocket/network/src/registerNetworkInformation.js":
/*!***********************************************************************!*\
  !*** ./packages/@logrocket/network/src/registerNetworkInformation.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = registerNetworkInformation;
var EFFECTIVE_TYPE_VALS = {
  'slow-2g': 'SLOW2G',
  '2g': 'TWOG',
  '3g': 'THREEG',
  '4g': 'FOURG'
};
function registerNetworkInformation(logger) {
  var lastStatus = undefined;
  function sendNetworkInformation() {
    var newStatus = {
      online: window.navigator.onLine,
      effectiveType: 'UNKOWN'
    };
    if (!window.navigator.onLine) {
      newStatus.effectiveType = 'NONE';
    } else if (window.navigator.connection && window.navigator.connection.effectiveType) {
      newStatus.effectiveType = EFFECTIVE_TYPE_VALS[window.navigator.connection.effectiveType] || 'UNKNOWN';
    }
    if (lastStatus && newStatus.online === lastStatus.online && newStatus.effectiveType === lastStatus.effectiveType) {
      return;
    }
    lastStatus = newStatus;
    logger.addEvent('lr.network.NetworkStatusEvent', function () {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$isEnabled = _ref.isEnabled,
        isEnabled = _ref$isEnabled === void 0 ? true : _ref$isEnabled;
      if (!isEnabled) {
        return null;
      }
      return newStatus;
    });
  }
  setTimeout(sendNetworkInformation);
  if (window.navigator.connection && typeof window.navigator.connection.addEventListener === 'function') {
    window.navigator.connection.addEventListener('change', sendNetworkInformation);
  }
  window.addEventListener('online', sendNetworkInformation);
  window.addEventListener('offline', sendNetworkInformation);
  return function () {
    window.removeEventListener('offline', sendNetworkInformation);
    window.removeEventListener('online', sendNetworkInformation);
    if (window.navigator.connection && typeof window.navigator.connection.removeEventListener === 'function') {
      window.navigator.connection.removeEventListener('change', sendNetworkInformation);
    }
  };
}

/***/ }),

/***/ "./packages/@logrocket/network/src/registerXHR.js":
/*!********************************************************!*\
  !*** ./packages/@logrocket/network/src/registerXHR.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.setActive = setActive;
exports["default"] = registerXHR;
var _mapValues = _interopRequireDefault(__webpack_require__(/*! @logrocket/utils/src/mapValues */ "./packages/@logrocket/utils/src/mapValues.js"));
var _enhanceFunc = _interopRequireDefault(__webpack_require__(/*! @logrocket/utils/src/enhanceFunc */ "./packages/@logrocket/utils/src/enhanceFunc.js"));
var _startsWith = _interopRequireDefault(__webpack_require__(/*! @logrocket/utils/src/startsWith */ "./packages/@logrocket/utils/src/startsWith.js"));
var _nps = __webpack_require__(/*! @logrocket/utils/src/constants/nps */ "./packages/@logrocket/utils/src/constants/nps.js");
// eslint-disable-line no-restricted-imports
// eslint-disable-line no-restricted-imports
// eslint-disable-line no-restricted-imports

var isActive = true;
function setActive(shouldBeActive) {
  isActive = shouldBeActive;
}
var currentXHRId = 0;
function registerXHR(_ref) {
  var addRequest = _ref.addRequest,
    addResponse = _ref.addResponse,
    isIgnored = _ref.isIgnored,
    logger = _ref.logger,
    _ref$shouldAugmentNPS = _ref.shouldAugmentNPS,
    shouldAugmentNPS = _ref$shouldAugmentNPS === void 0 ? true : _ref$shouldAugmentNPS,
    _ref$shouldParseXHRBl = _ref.shouldParseXHRBlob,
    shouldParseXHRBlob = _ref$shouldParseXHRBl === void 0 ? false : _ref$shouldParseXHRBl;
  var _XHR = XMLHttpRequest;
  var xhrMap = new WeakMap();
  var unsubscribedFromXhr = false;
  var LOGROCKET_XHR_LABEL = 'xhr-';
  window._lrXMLHttpRequest = XMLHttpRequest;

  // eslint-disable-next-line no-native-reassign
  XMLHttpRequest = function XMLHttpRequest(mozAnon, mozSystem) {
    var xhrObject = new _XHR(mozAnon, mozSystem);
    if (!isActive) {
      return xhrObject;
    }
    xhrMap.set(xhrObject, {
      xhrId: ++currentXHRId,
      headers: {}
    });
    var openOriginal = xhrObject.open;
    function openShim() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      try {
        var url = args[1];
        if (window.URL && typeof window.URL === 'function' && url.search(_nps.WOOTRIC_RESPONSES_REGEX) === 0) {
          var logrocketSessionURL = new window.URL(logger.recordingURL);
          logrocketSessionURL.searchParams.set('nps', 'wootric');
          var urlObj = new window.URL(url);
          var responseText = urlObj.searchParams.get('response[text]');
          var feedback = responseText ? "".concat(responseText, "\n\n") : '';
          urlObj.searchParams.set('response[text]', "".concat(feedback, "<").concat(logrocketSessionURL.href, "|View LogRocket session>"));
          args[1] = urlObj.href; // eslint-disable-line no-param-reassign
        }
      } catch (e) {/* do nothing */}
      return openOriginal.apply(this, args);
    }
    var sendOriginal = xhrObject.send;
    function sendShim() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      try {
        var currentXHR = xhrMap.get(xhrObject);
        if (window.URL && typeof window.URL === 'function' && currentXHR && currentXHR.url && currentXHR.url.search(_nps.DELIGHTED_RESPONSES_REGEX) === 0 && args.length && args[0].indexOf(_nps.DELIGHTED_FEEDBACK_PREFIX) !== -1) {
          var recordingURL = new window.URL(logger.recordingURL);
          recordingURL.searchParams.set('nps', 'delighted');
          var logrocketSessionURL = encodeURIComponent(recordingURL.href);
          var data = args[0].split('&').map(function (dataString) {
            if ((0, _startsWith.default)(dataString, _nps.DELIGHTED_FEEDBACK_PREFIX)) {
              var isEmpty = dataString === _nps.DELIGHTED_FEEDBACK_PREFIX;
              return "".concat(dataString).concat(isEmpty ? '' : '\n\n', "<").concat(logrocketSessionURL, "|View LogRocket session>");
            }
            return dataString;
          }).join('&');
          args[0] = data; // eslint-disable-line no-param-reassign
        }
      } catch (e) {/* do nothing */}
      return sendOriginal.apply(this, args);
    }
    if (shouldAugmentNPS) {
      xhrObject.open = openShim;
      xhrObject.send = sendShim;
    }

    // ..., 'open', (method, url, async, username, password) => {
    (0, _enhanceFunc.default)(xhrObject, 'open', function (method, url) {
      if (unsubscribedFromXhr) {
        return;
      }
      var currentXHR = xhrMap.get(xhrObject);
      currentXHR.method = method;
      currentXHR.url = url;
    });
    (0, _enhanceFunc.default)(xhrObject, 'send', function (data) {
      if (unsubscribedFromXhr) {
        return;
      }
      var currentXHR = xhrMap.get(xhrObject);
      if (!currentXHR) {
        return;
      }
      var request = {
        url: currentXHR.url,
        method: currentXHR.method && currentXHR.method.toUpperCase(),
        headers: (0, _mapValues.default)(currentXHR.headers || {}, function (headerValues) {
          return headerValues.join(', ');
        }),
        body: data
      };
      addRequest("".concat(LOGROCKET_XHR_LABEL).concat(currentXHR.xhrId), request);
    });
    (0, _enhanceFunc.default)(xhrObject, 'setRequestHeader', function (header, value) {
      if (unsubscribedFromXhr) {
        return;
      }
      var currentXHR = xhrMap.get(xhrObject);
      if (!currentXHR) {
        return;
      }
      currentXHR.headers = currentXHR.headers || {};
      currentXHR.headers[header] = currentXHR.headers[header] || [];
      currentXHR.headers[header].push(value);
    });
    var xhrListeners = {
      readystatechange: function readystatechange() {
        if (unsubscribedFromXhr) {
          return;
        }
        if (xhrObject.readyState === 4) {
          var currentXHR = xhrMap.get(xhrObject);
          if (!currentXHR) {
            return;
          }

          // Do not read ignored requests at all.
          if (isIgnored("".concat(LOGROCKET_XHR_LABEL).concat(currentXHR.xhrId))) {
            return;
          }
          var headerString = xhrObject.getAllResponseHeaders() || '';
          var headers = headerString.split(/[\r\n]+/).reduce(function (previous, current) {
            var next = previous;
            var headerParts = current.split(': ');
            if (headerParts.length > 0) {
              var key = headerParts.shift(); // first index of the array
              var value = headerParts.join(': '); // rest of the array repaired
              if (previous[key]) {
                next[key] += ", ".concat(value);
              } else {
                next[key] = value;
              }
            }
            return next;
          }, {});
          var body;

          // IE 11 sometimes throws when trying to access large responses
          try {
            switch (xhrObject.responseType) {
              case 'json':
                body = logger._shouldCloneResponse ? JSON.parse(JSON.stringify(xhrObject.response)) : xhrObject.response;
                break;
              case 'arraybuffer':
              case 'blob':
                {
                  body = xhrObject.response;
                  break;
                }
              case 'document':
                {
                  body = xhrObject.responseXML;
                  break;
                }
              case 'text':
              case '':
                {
                  body = xhrObject.responseText;
                  break;
                }
              default:
                {
                  body = '';
                }
            }
          } catch (err) {
            body = 'LogRocket: Error accessing response.';
          }
          var response = {
            url: currentXHR.url,
            status: xhrObject.status,
            headers: headers,
            body: body,
            method: (currentXHR.method || '').toUpperCase()
          };
          if (shouldParseXHRBlob && response.body instanceof Blob) {
            var blobReader = new FileReader();
            blobReader.readAsText(response.body);
            blobReader.onload = function () {
              try {
                response.body = JSON.parse(blobReader.result);
              } catch (_unused) {} // eslint-disable-line no-empty
              addResponse("".concat(LOGROCKET_XHR_LABEL).concat(currentXHR.xhrId), response);
            };
          } else {
            addResponse("".concat(LOGROCKET_XHR_LABEL).concat(currentXHR.xhrId), response);
          }
        }
      }
      // // Unused Event Listeners
      // loadstart: () => {},
      // progress: () => {},
      // abort: () => {},
      // error: () => {},
      // load: () => {},
      // timeout: () => {},
      // loadend: () => {},
    };

    Object.keys(xhrListeners).forEach(function (key) {
      xhrObject.addEventListener(key, xhrListeners[key]);
    });
    return xhrObject;
  };

  // this allows "instanceof XMLHttpRequest" to work
  XMLHttpRequest.prototype = _XHR.prototype;

  // Persist the static variables.
  ['UNSENT', 'OPENED', 'HEADERS_RECEIVED', 'LOADING', 'DONE'].forEach(function (variable) {
    XMLHttpRequest[variable] = _XHR[variable];
  });
  return function () {
    unsubscribedFromXhr = true;
    // eslint-disable-next-line no-native-reassign
    XMLHttpRequest = _XHR;
  };
}

/***/ }),

/***/ "./packages/@logrocket/now/src/index.js":
/*!**********************************************!*\
  !*** ./packages/@logrocket/now/src/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
/* eslint-disable compat/compat */
var dateNow = Date.now.bind(Date);
var loadTime = dateNow();
var _default = typeof performance !== 'undefined' && performance.now ? performance.now.bind(performance) : function () {
  return dateNow() - loadTime;
};
exports["default"] = _default;

/***/ }),

/***/ "./packages/@logrocket/redux/src/createEnhancer.js":
/*!*********************************************************!*\
  !*** ./packages/@logrocket/redux/src/createEnhancer.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = createEnhancer;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));
var _now = _interopRequireDefault(__webpack_require__(/*! @logrocket/now */ "./packages/@logrocket/now/src/index.js"));
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var storeIdCounter = 0;
function createEnhancer(logger) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref$stateSanitizer = _ref.stateSanitizer,
    stateSanitizer = _ref$stateSanitizer === void 0 ? function (f) {
      return f;
    } : _ref$stateSanitizer,
    _ref$actionSanitizer = _ref.actionSanitizer,
    actionSanitizer = _ref$actionSanitizer === void 0 ? function (f) {
      return f;
    } : _ref$actionSanitizer;
  // an enhancer is a function that returns a Store
  return function (createStore) {
    return function (reducer, initialState, enhancer) {
      var store = createStore(reducer, initialState, enhancer);
      var originalDispatch = store.dispatch;
      var storeId = storeIdCounter++;
      logger.addEvent('lr.redux.InitialState', function () {
        var sanitizedState;
        try {
          // only try catch user defined functions
          sanitizedState = stateSanitizer(store.getState());
        } catch (err) {
          console.error(err.toString());
        }
        return {
          state: sanitizedState,
          storeId: storeId
        };
      });
      var dispatch = function dispatch(action) {
        var start = (0, _now.default)();
        var err;
        var res;
        try {
          res = originalDispatch(action);
        } catch (_err) {
          err = _err;
        } finally {
          var duration = (0, _now.default)() - start;
          logger.addEvent('lr.redux.ReduxAction', function () {
            var sanitizedState = null;
            var sanitizedAction = null;
            try {
              // only try catch user defined functions
              sanitizedState = stateSanitizer(store.getState());
              sanitizedAction = actionSanitizer(action);
            } catch (err) {
              console.error(err.toString());
            }
            if (sanitizedState && sanitizedAction) {
              return {
                storeId: storeId,
                action: sanitizedAction,
                duration: duration,
                stateDelta: sanitizedState
              };
            }
            return null;
          });
        }
        if (err) {
          throw err;
        }
        return res;
      };
      return _objectSpread(_objectSpread({}, store), {}, {
        dispatch: dispatch
      });
    };
  };
}

/***/ }),

/***/ "./packages/@logrocket/redux/src/createMiddleware.js":
/*!***********************************************************!*\
  !*** ./packages/@logrocket/redux/src/createMiddleware.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = createMiddleware;
var _now = _interopRequireDefault(__webpack_require__(/*! @logrocket/now */ "./packages/@logrocket/now/src/index.js"));
var storeIdCounter = 0;
function createMiddleware(logger) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref$stateSanitizer = _ref.stateSanitizer,
    stateSanitizer = _ref$stateSanitizer === void 0 ? function (f) {
      return f;
    } : _ref$stateSanitizer,
    _ref$actionSanitizer = _ref.actionSanitizer,
    actionSanitizer = _ref$actionSanitizer === void 0 ? function (f) {
      return f;
    } : _ref$actionSanitizer;
  return function (store) {
    var storeId = storeIdCounter++;
    logger.addEvent('lr.redux.InitialState', function () {
      var sanitizedState;
      try {
        // only try catch user defined functions
        sanitizedState = stateSanitizer(store.getState());
      } catch (err) {
        console.error(err.toString());
      }
      return {
        state: sanitizedState,
        storeId: storeId
      };
    });
    return function (next) {
      return function (action) {
        var start = (0, _now.default)();
        var err;
        var res;
        try {
          res = next(action);
        } catch (_err) {
          err = _err;
        } finally {
          var duration = (0, _now.default)() - start;
          logger.addEvent('lr.redux.ReduxAction', function () {
            var sanitizedState = null;
            var sanitizedAction = null;
            try {
              // only try catch user defined functions
              sanitizedState = stateSanitizer(store.getState());
              sanitizedAction = actionSanitizer(action);
            } catch (err) {
              console.error(err.toString());
            }
            if (sanitizedState && sanitizedAction) {
              return {
                storeId: storeId,
                action: sanitizedAction,
                duration: duration,
                stateDelta: sanitizedState
              };
            }
            return null;
          });
        }
        if (err) {
          throw err;
        }
        return res;
      };
    };
  };
}

/***/ }),

/***/ "./packages/@logrocket/redux/src/index.js":
/*!************************************************!*\
  !*** ./packages/@logrocket/redux/src/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "createEnhancer", ({
  enumerable: true,
  get: function get() {
    return _createEnhancer.default;
  }
}));
Object.defineProperty(exports, "createMiddleware", ({
  enumerable: true,
  get: function get() {
    return _createMiddleware.default;
  }
}));
var _createEnhancer = _interopRequireDefault(__webpack_require__(/*! ./createEnhancer */ "./packages/@logrocket/redux/src/createEnhancer.js"));
var _createMiddleware = _interopRequireDefault(__webpack_require__(/*! ./createMiddleware */ "./packages/@logrocket/redux/src/createMiddleware.js"));

/***/ }),

/***/ "./packages/@logrocket/utils/src/TraceKit.js":
/*!***************************************************!*\
  !*** ./packages/@logrocket/utils/src/TraceKit.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* eslint-disable */



/*
 TraceKit - Cross browser stack traces - github.com/occ/TraceKit

 This was originally forked from github.com/occ/TraceKit, but has since been
 largely re-written and is now maintained as part of raven-js.  Tests for
 this are in test/vendor.

 MIT license
*/
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var TraceKit = {
  collectWindowErrors: true,
  debug: false
};

// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)
var _window = typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};

// global reference to slice
var _slice = [].slice;
var UNKNOWN_FUNCTION = '?';

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types
var ERROR_TYPES_RE = /^(?:Uncaught (?:exception: )?)?((?:Eval|Internal|Range|Reference|Syntax|Type|URI)Error): ?(.*)$/;
function getLocationHref() {
  if (typeof document === 'undefined' || typeof document.location === 'undefined') return '';
  return document.location.href;
}

/**
 * TraceKit.report: cross-browser processing of unhandled exceptions
 *
 * Syntax:
 *   TraceKit.report.subscribe(function(stackInfo) { ... })
 *   TraceKit.report.unsubscribe(function(stackInfo) { ... })
 *   TraceKit.report(exception)
 *   try { ...code... } catch(ex) { TraceKit.report(ex); }
 *
 * Supports:
 *   - Firefox: full stack trace with line numbers, plus column number
 *              on top frame; column number is not guaranteed
 *   - Opera:   full stack trace with line and column numbers
 *   - Chrome:  full stack trace with line and column numbers
 *   - Safari:  line and column number for the top frame only; some frames
 *              may be missing, and column number is not guaranteed
 *   - IE:      line and column number for the top frame only; some frames
 *              may be missing, and column number is not guaranteed
 *
 * In theory, TraceKit should work on all of the following versions:
 *   - IE5.5+ (only 8.0 tested)
 *   - Firefox 0.9+ (only 3.5+ tested)
 *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require
 *     Exceptions Have Stacktrace to be enabled in opera:config)
 *   - Safari 3+ (only 4+ tested)
 *   - Chrome 1+ (only 5+ tested)
 *   - Konqueror 3.5+ (untested)
 *
 * Requires TraceKit.computeStackTrace.
 *
 * Tries to catch all unhandled exceptions and report them to the
 * subscribed handlers. Please note that TraceKit.report will rethrow the
 * exception. This is REQUIRED in order to get a useful stack trace in IE.
 * If the exception does not reach the top of the browser, you will only
 * get a stack trace from the point where TraceKit.report was called.
 *
 * Handlers receive a stackInfo object as described in the
 * TraceKit.computeStackTrace docs.
 */
TraceKit.report = function reportModuleWrapper() {
  var handlers = [],
    lastArgs = null,
    lastException = null,
    lastExceptionStack = null;

  /**
   * Add a crash handler.
   * @param {Function} handler
   */
  function subscribe(handler) {
    installGlobalHandler();
    handlers.push(handler);
  }

  /**
   * Remove a crash handler.
   * @param {Function} handler
   */
  function unsubscribe(handler) {
    for (var i = handlers.length - 1; i >= 0; --i) {
      if (handlers[i] === handler) {
        handlers.splice(i, 1);
      }
    }
  }

  /**
   * Remove all crash handlers.
   */
  function unsubscribeAll() {
    uninstallGlobalHandler();
    handlers = [];
  }

  /**
   * Dispatch stack information to all handlers.
   * @param {Object.<string, *>} stack
   */
  function notifyHandlers(stack, isWindowError) {
    var exception = null;
    if (isWindowError && !TraceKit.collectWindowErrors) {
      return;
    }
    for (var i in handlers) {
      if (handlers.hasOwnProperty(i)) {
        try {
          handlers[i].apply(null, [stack].concat(_slice.call(arguments, 2)));
        } catch (inner) {
          exception = inner;
        }
      }
    }
    if (exception) {
      throw exception;
    }
  }
  var _oldOnerrorHandler, _onErrorHandlerInstalled;

  /**
   * Ensures all global unhandled exceptions are recorded.
   * Supported by Gecko and IE.
   * @param {string} message Error message.
   * @param {string} url URL of script that generated the exception.
   * @param {(number|string)} lineNo The line number at which the error
   * occurred.
   * @param {?(number|string)} colNo The column number at which the error
   * occurred.
   * @param {?Error} ex The actual Error object.
   */
  function traceKitWindowOnError(message, url, lineNo, colNo, ex) {
    var stack = null;
    if (lastExceptionStack) {
      TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack, url, lineNo, message);
      processLastException();
    } else if (ex) {
      // New chrome and blink send along a real error object
      // Let's just report that like a normal error.
      // See: https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror
      stack = TraceKit.computeStackTrace(ex);
      notifyHandlers(stack, true);
    } else {
      var location = {
        'url': url,
        'line': lineNo,
        'column': colNo
      };
      var name = undefined;
      var msg = message; // must be new var or will modify original `arguments`
      var groups;
      if ({}.toString.call(message) === '[object String]') {
        var groups = message.match(ERROR_TYPES_RE);
        if (groups) {
          name = groups[1];
          msg = groups[2];
        }
      }
      location.func = UNKNOWN_FUNCTION;
      stack = {
        'name': name,
        'message': msg,
        'url': getLocationHref(),
        'stack': [location]
      };
      notifyHandlers(stack, true);
    }
    if (_oldOnerrorHandler) {
      return _oldOnerrorHandler.apply(this, arguments);
    }
    return false;
  }
  function installGlobalHandler() {
    if (_onErrorHandlerInstalled) {
      return;
    }
    _oldOnerrorHandler = _window.onerror;
    _window.onerror = traceKitWindowOnError;
    _onErrorHandlerInstalled = true;
  }
  function uninstallGlobalHandler() {
    if (!_onErrorHandlerInstalled) {
      return;
    }
    _window.onerror = _oldOnerrorHandler;
    _onErrorHandlerInstalled = false;
    _oldOnerrorHandler = undefined;
  }
  function processLastException() {
    var _lastExceptionStack = lastExceptionStack,
      _lastArgs = lastArgs;
    lastArgs = null;
    lastExceptionStack = null;
    lastException = null;
    notifyHandlers.apply(null, [_lastExceptionStack, false].concat(_lastArgs));
  }

  /**
   * Reports an unhandled Error to TraceKit.
   * @param {Error} ex
   * @param {?boolean} rethrow If false, do not re-throw the exception.
   * Only used for window.onerror to not cause an infinite loop of
   * rethrowing.
   */
  function report(ex, rethrow) {
    var args = _slice.call(arguments, 1);
    if (lastExceptionStack) {
      if (lastException === ex) {
        return; // already caught by an inner catch block, ignore
      } else {
        processLastException();
      }
    }
    var stack = TraceKit.computeStackTrace(ex);
    lastExceptionStack = stack;
    lastException = ex;
    lastArgs = args;

    // If the stack trace is incomplete, wait for 2 seconds for
    // slow slow IE to see if onerror occurs or not before reporting
    // this exception; otherwise, we will end up with an incomplete
    // stack trace
    setTimeout(function () {
      if (lastException === ex) {
        processLastException();
      }
    }, stack.incomplete ? 2000 : 0);
    if (rethrow !== false) {
      throw ex; // re-throw to propagate to the top level (and cause window.onerror)
    }
  }

  report.subscribe = subscribe;
  report.unsubscribe = unsubscribe;
  report.uninstall = unsubscribeAll;
  return report;
}();

/**
 * TraceKit.computeStackTrace: cross-browser stack traces in JavaScript
 *
 * Syntax:
 *   s = TraceKit.computeStackTrace(exception) // consider using TraceKit.report instead (see below)
 * Returns:
 *   s.name              - exception name
 *   s.message           - exception message
 *   s.stack[i].url      - JavaScript or HTML file URL
 *   s.stack[i].func     - function name, or empty for anonymous functions (if guessing did not work)
 *   s.stack[i].args     - arguments passed to the function, if known
 *   s.stack[i].line     - line number, if known
 *   s.stack[i].column   - column number, if known
 *
 * Supports:
 *   - Firefox:  full stack trace with line numbers and unreliable column
 *               number on top frame
 *   - Opera 10: full stack trace with line and column numbers
 *   - Opera 9-: full stack trace with line numbers
 *   - Chrome:   full stack trace with line and column numbers
 *   - Safari:   line and column number for the topmost stacktrace element
 *               only
 *   - IE:       no line numbers whatsoever
 *
 * Tries to guess names of anonymous functions by looking for assignments
 * in the source code. In IE and Safari, we have to guess source file names
 * by searching for function bodies inside all page scripts. This will not
 * work for scripts that are loaded cross-domain.
 * Here be dragons: some function names may be guessed incorrectly, and
 * duplicate functions may be mismatched.
 *
 * TraceKit.computeStackTrace should only be used for tracing purposes.
 * Logging of unhandled exceptions should be done with TraceKit.report,
 * which builds on top of TraceKit.computeStackTrace and provides better
 * IE support by utilizing the window.onerror event to retrieve information
 * about the top of the stack.
 *
 * Note: In IE and Safari, no stack trace is recorded on the Error object,
 * so computeStackTrace instead walks its *own* chain of callers.
 * This means that:
 *  * in Safari, some methods may be missing from the stack trace;
 *  * in IE, the topmost function in the stack trace will always be the
 *    caller of computeStackTrace.
 *
 * This is okay for tracing (because you are likely to be calling
 * computeStackTrace from the function you want to be the topmost element
 * of the stack trace anyway), but not okay for logging unhandled
 * exceptions (because your catch block will likely be far away from the
 * inner function that actually caused the exception).
 *
 */
TraceKit.computeStackTrace = function computeStackTraceWrapper() {
  /**
   * Escapes special characters, except for whitespace, in a string to be
   * used inside a regular expression as a string literal.
   * @param {string} text The string.
   * @return {string} The escaped string literal.
   */
  function escapeRegExp(text) {
    return text.replace(/[\-\[\]{}()*+?.,\\\^$|#]/g, '\\$&');
  }

  /**
   * Escapes special characters in a string to be used inside a regular
   * expression as a string literal. Also ensures that HTML entities will
   * be matched the same as their literal friends.
   * @param {string} body The string.
   * @return {string} The escaped string.
   */
  function escapeCodeAsRegExpForMatchingInsideHTML(body) {
    return escapeRegExp(body).replace('<', '(?:<|&lt;)').replace('>', '(?:>|&gt;)').replace('&', '(?:&|&amp;)').replace('"', '(?:"|&quot;)').replace(/\s+/g, '\\s+');
  }

  // Contents of Exception in various browsers.
  //
  // SAFARI:
  // ex.message = Can't find variable: qq
  // ex.line = 59
  // ex.sourceId = 580238192
  // ex.sourceURL = http://...
  // ex.expressionBeginOffset = 96
  // ex.expressionCaretOffset = 98
  // ex.expressionEndOffset = 98
  // ex.name = ReferenceError
  //
  // FIREFOX:
  // ex.message = qq is not defined
  // ex.fileName = http://...
  // ex.lineNumber = 59
  // ex.columnNumber = 69
  // ex.stack = ...stack trace... (see the example below)
  // ex.name = ReferenceError
  //
  // CHROME:
  // ex.message = qq is not defined
  // ex.name = ReferenceError
  // ex.type = not_defined
  // ex.arguments = ['aa']
  // ex.stack = ...stack trace...
  //
  // INTERNET EXPLORER:
  // ex.message = ...
  // ex.name = ReferenceError
  //
  // OPERA:
  // ex.message = ...message... (see the example below)
  // ex.name = ReferenceError
  // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)
  // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'

  /**
   * Computes stack trace information from the stack property.
   * Chrome and Gecko use this property.
   * @param {Error} ex
   * @return {?Object.<string, *>} Stack trace information.
   */
  function computeStackTraceFromStackProp(ex) {
    if (typeof ex.stack === 'undefined' || !ex.stack) return;
    var chrome = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|<anonymous>).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
      gecko = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|resource|\[native).*?)(?::(\d+))?(?::(\d+))?\s*$/i,
      winjs = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i,
      lines = ex.stack.split('\n'),
      stack = [],
      parts,
      element,
      reference = /^(.*) is undefined$/.exec(ex.message);
    for (var i = 0, j = lines.length; i < j; ++i) {
      if (parts = chrome.exec(lines[i])) {
        var isNative = parts[2] && parts[2].indexOf('native') !== -1;
        element = {
          'url': !isNative ? parts[2] : null,
          'func': parts[1] || UNKNOWN_FUNCTION,
          'args': isNative ? [parts[2]] : [],
          'line': parts[3] ? +parts[3] : null,
          'column': parts[4] ? +parts[4] : null
        };
      } else if (parts = winjs.exec(lines[i])) {
        element = {
          'url': parts[2],
          'func': parts[1] || UNKNOWN_FUNCTION,
          'args': [],
          'line': +parts[3],
          'column': parts[4] ? +parts[4] : null
        };
      } else if (parts = gecko.exec(lines[i])) {
        element = {
          'url': parts[3],
          'func': parts[1] || UNKNOWN_FUNCTION,
          'args': parts[2] ? parts[2].split(',') : [],
          'line': parts[4] ? +parts[4] : null,
          'column': parts[5] ? +parts[5] : null
        };
      } else {
        continue;
      }
      if (!element.func && element.line) {
        element.func = UNKNOWN_FUNCTION;
      }
      stack.push(element);
    }
    if (!stack.length) {
      return null;
    }
    if (!stack[0].column && typeof ex.columnNumber !== 'undefined') {
      // FireFox uses this awesome columnNumber property for its top frame
      // Also note, Firefox's column number is 0-based and everything else expects 1-based,
      // so adding 1
      stack[0].column = ex.columnNumber + 1;
    }
    return {
      'name': ex.name,
      'message': ex.message,
      'url': getLocationHref(),
      'stack': stack
    };
  }

  /**
   * Adds information about the first frame to incomplete stack traces.
   * Safari and IE require this to get complete data on the first frame.
   * @param {Object.<string, *>} stackInfo Stack trace information from
   * one of the compute* methods.
   * @param {string} url The URL of the script that caused an error.
   * @param {(number|string)} lineNo The line number of the script that
   * caused an error.
   * @param {string=} message The error generated by the browser, which
   * hopefully contains the name of the object that caused the error.
   * @return {boolean} Whether or not the stack information was
   * augmented.
   */
  function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {
    var initial = {
      'url': url,
      'line': lineNo
    };
    if (initial.url && initial.line) {
      stackInfo.incomplete = false;
      if (!initial.func) {
        initial.func = UNKNOWN_FUNCTION;
      }
      if (stackInfo.stack.length > 0) {
        if (stackInfo.stack[0].url === initial.url) {
          if (stackInfo.stack[0].line === initial.line) {
            return false; // already in stack trace
          } else if (!stackInfo.stack[0].line && stackInfo.stack[0].func === initial.func) {
            stackInfo.stack[0].line = initial.line;
            return false;
          }
        }
      }
      stackInfo.stack.unshift(initial);
      stackInfo.partial = true;
      return true;
    } else {
      stackInfo.incomplete = true;
    }
    return false;
  }

  /**
   * Computes stack trace information by walking the arguments.caller
   * chain at the time the exception occurred. This will cause earlier
   * frames to be missed but is the only way to get any stack trace in
   * Safari and IE. The top frame is restored by
   * {@link augmentStackTraceWithInitialElement}.
   * @param {Error} ex
   * @return {?Object.<string, *>} Stack trace information.
   */
  function computeStackTraceByWalkingCallerChain(ex, depth) {
    var functionName = /function\s+([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?\s*\(/i,
      stack = [],
      funcs = {},
      recursion = false,
      parts,
      item,
      source;
    for (var curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {
      if (curr === computeStackTrace || curr === TraceKit.report) {
        // console.log('skipping internal function');
        continue;
      }
      item = {
        'url': null,
        'func': UNKNOWN_FUNCTION,
        'line': null,
        'column': null
      };
      if (curr.name) {
        item.func = curr.name;
      } else if (parts = functionName.exec(curr.toString())) {
        item.func = parts[1];
      }
      if (typeof item.func === 'undefined') {
        try {
          item.func = parts.input.substring(0, parts.input.indexOf('{'));
        } catch (e) {}
      }
      if (funcs['' + curr]) {
        recursion = true;
      } else {
        funcs['' + curr] = true;
      }
      stack.push(item);
    }
    if (depth) {
      // console.log('depth is ' + depth);
      // console.log('stack is ' + stack.length);
      stack.splice(0, depth);
    }
    var result = {
      'name': ex.name,
      'message': ex.message,
      'url': getLocationHref(),
      'stack': stack
    };
    augmentStackTraceWithInitialElement(result, ex.sourceURL || ex.fileName, ex.line || ex.lineNumber, ex.message || ex.description);
    return result;
  }

  /**
   * Computes a stack trace for an exception.
   * @param {Error} ex
   * @param {(string|number)=} depth
   */
  function computeStackTrace(ex, depth) {
    var stack = null;
    depth = depth == null ? 0 : +depth;
    try {
      stack = computeStackTraceFromStackProp(ex);
      if (stack) {
        return stack;
      }
    } catch (e) {
      if (TraceKit.debug) {
        throw e;
      }
    }
    try {
      stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);
      if (stack) {
        return stack;
      }
    } catch (e) {
      if (TraceKit.debug) {
        throw e;
      }
    }
    return {
      'name': ex.name,
      'message': ex.message,
      'url': getLocationHref()
    };
  }
  computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;
  computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;
  return computeStackTrace;
}();
var _default = TraceKit;
exports["default"] = _default;

/***/ }),

/***/ "./packages/@logrocket/utils/src/addListener.js":
/*!******************************************************!*\
  !*** ./packages/@logrocket/utils/src/addListener.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = addListener;
function addListener(type, handler) {
  var obj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;
  var _handler = handler;
  obj.addEventListener(type, function () {
    if (_handler) {
      _handler.apply(void 0, arguments);
    }
  }, {
    capture: true,
    passive: true
  });
  return function () {
    _handler = null;
  };
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/adjustOsVersion.ts":
/*!**********************************************************!*\
  !*** ./packages/@logrocket/utils/src/adjustOsVersion.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.adjustOsVersion = adjustOsVersion;
exports.adjustOs = adjustOs;
function adjustOsVersion(osName, osVersionStr) {
  var osVersion = osVersionStr;
  if (osVersionStr && osName.toLowerCase().replace(/\s/g, '').indexOf('macos') > -1) {
    osVersion = osVersionStr.replace('10.15.7', '10.15.7+');
  }
  return osVersion;
}

// Used when os name and version are combined in 1 string, i.e. "Mac OS X 10.15.7"
function adjustOs(os) {
  return adjustOsVersion(os, os);
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/applyUrlSanitizer.js":
/*!************************************************************!*\
  !*** ./packages/@logrocket/utils/src/applyUrlSanitizer.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = applyUrlSanitizer;
function applyUrlSanitizer(_ref) {
  var logger = _ref.logger,
    _ref$url = _ref.url,
    url = _ref$url === void 0 ? '' : _ref$url;
  var _ref2 = logger.getConfig('lr.browser') || {},
    _ref2$urlSanitizer = _ref2.urlSanitizer,
    urlSanitizer = _ref2$urlSanitizer === void 0 ? function (originalUrl) {
      return originalUrl;
    } : _ref2$urlSanitizer;
  var sanitizedValue;
  try {
    sanitizedValue = urlSanitizer(url);
  } catch (err) {
    console.error(err);
  }
  if (typeof sanitizedValue === 'string') {
    return sanitizedValue;
  }

  // if something went wrong or was set to null, redact completely
  return '';
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/browserUtils.js":
/*!*******************************************************!*\
  !*** ./packages/@logrocket/utils/src/browserUtils.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getNodeName = getNodeName;
exports.getTargetForEvent = getTargetForEvent;
exports.getNodePath = getNodePath;
function getNodeName(node) {
  if (node.nodeName === '#document-fragment' && node.mode === 'open') {
    return '$shadow-root';
  } else if (node.nodeName) {
    return node.nodeName.toLowerCase();
  }
  return '';
}
function getTargetForEvent(event) {
  if (typeof event.composedPath === 'function' && event.composed) {
    return event.composedPath()[0];
  } else if (event.path) {
    return event.path[0];
  }
  return event.target;
}

// maximum size of selector string, after which we no longer walk up the DOM tree to calculate
// the node path. This cannot be larger than 2048
var SELECTOR_MAX_LENGTH = 1000;
function getNodePath(element) {
  var activeNode = element;
  var nodePath = [];
  var nodePathLength = 0;
  while (activeNode && (activeNode.parentNode || activeNode.host)) {
    var nodeName = getNodeName(activeNode);

    // end at the body
    if (nodeName === 'body') {
      break;
    }
    var selector = {
      nodeName: nodeName
    };
    var selectorLength = selector.nodeName.length;
    if (activeNode.id && activeNode.id.length > 0) {
      selector.id = activeNode.id;
      selectorLength += activeNode.id.length;
    }
    if (activeNode.classList && activeNode.classList.length > 0) {
      selector.classList = Array.prototype.slice.call(activeNode.classList, 0);
      var classNames = Array.prototype.join.call(activeNode.classList, '');
      // classNames sometimes is null
      if (classNames) {
        selectorLength += classNames.length;
      }
    }
    if (nodePathLength + selectorLength > SELECTOR_MAX_LENGTH) {
      break;
    }

    // IE11 may not have a children NodeList, and shadowRoots will not have a parentNode
    if (activeNode.parentNode && activeNode.parentNode.children) {
      try {
        var nthChild = 0;
        var siblingNode = activeNode;
        do {
          nthChild += 1;
          siblingNode = siblingNode.previousElementSibling;
        } while (siblingNode);
        selector.nthChild = nthChild;
      } catch (_) {
        /* IE appears to provide a null/undefined value for children in some rare cases? */
      }
    }
    nodePathLength += selectorLength;
    nodePath.push(selector);
    activeNode = activeNode.parentNode || activeNode.host;
  }
  return nodePath;
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/constants/issues.ts":
/*!***********************************************************!*\
  !*** ./packages/@logrocket/utils/src/constants/issues.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ES_ISSUE_TYPE_BASE_FILTER = exports.ES_ISSUE_TYPES = exports.ISSUE_GROUP_TYPE = exports.ISSUE_TYPE = void 0;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));
var _ES_ISSUE_TYPE_BASE_F;
var ISSUE_TYPE = {
  EXCEPTION: 'EXCEPTION',
  NETWORK_ERROR: 'NETWORK_ERROR',
  RAGE_CLICK: 'RAGE_CLICK',
  DEAD_CLICK: 'DEAD_CLICK',
  FRUSTRATING_NETWORK: 'FRUSTRATING_NETWORK',
  ERROR_STATE: 'ERROR_STATE'
};
exports.ISSUE_TYPE = ISSUE_TYPE;
var ISSUE_GROUP_TYPE = {
  ENCODED_FILTER: 'ENCODED_FILTER',
  SENTRY: 'SENTRY',
  TROYTOWN: 'TROYTOWN'
};
exports.ISSUE_GROUP_TYPE = ISSUE_GROUP_TYPE;
var ES_ISSUE_TYPES = [ISSUE_TYPE.RAGE_CLICK, ISSUE_TYPE.DEAD_CLICK, ISSUE_TYPE.FRUSTRATING_NETWORK, ISSUE_TYPE.ERROR_STATE];
exports.ES_ISSUE_TYPES = ES_ISSUE_TYPES;
var ES_ISSUE_TYPE_BASE_FILTER = (_ES_ISSUE_TYPE_BASE_F = {}, (0, _defineProperty2.default)(_ES_ISSUE_TYPE_BASE_F, ISSUE_TYPE.RAGE_CLICK, {
  rageClicked: {
    operator: 'TEXT_IS',
    strings: []
  }
}), (0, _defineProperty2.default)(_ES_ISSUE_TYPE_BASE_F, ISSUE_TYPE.DEAD_CLICK, {
  deadClicked: {
    operator: 'TEXT_IS',
    strings: []
  }
}), _ES_ISSUE_TYPE_BASE_F);
exports.ES_ISSUE_TYPE_BASE_FILTER = ES_ISSUE_TYPE_BASE_FILTER;

/***/ }),

/***/ "./packages/@logrocket/utils/src/constants/logTypes.js":
/*!*************************************************************!*\
  !*** ./packages/@logrocket/utils/src/constants/logTypes.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LOG_FILTER_TYPES = exports.LOG_TYPES = void 0;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));
var _LOG_FILTER_TYPES;
var LOG_TYPES = {
  LOG: 'LOG',
  WARN: 'WARN',
  ERROR: 'ERROR',
  DEBUG: 'DEBUG',
  INFO: 'INFO',
  REDUX: 'REDUX',
  LIFECYCLE: 'LIFECYCLE',
  NAVIGATION: 'NAVIGATION',
  NETWORK: 'NETWORK',
  PREV_SESSION: 'PREV_SESSION',
  NEXT_SESSION: 'NEXT_SESSION',
  LOAD_MORE: 'LOAD_MORE',
  EXCEPTION: 'EXCEPTION',
  CRASH: 'CRASH'
};
exports.LOG_TYPES = LOG_TYPES;
var LOG_FILTER_TYPES = (_LOG_FILTER_TYPES = {}, (0, _defineProperty2.default)(_LOG_FILTER_TYPES, LOG_TYPES.LOG, {
  label: 'Logs',
  filterLabel: 'Log',
  types: [LOG_TYPES.LOG]
}), (0, _defineProperty2.default)(_LOG_FILTER_TYPES, LOG_TYPES.WARN, {
  label: 'Warnings',
  filterLabel: 'Warning',
  types: [LOG_TYPES.WARN]
}), (0, _defineProperty2.default)(_LOG_FILTER_TYPES, LOG_TYPES.ERROR, {
  label: 'Errors',
  filterLabel: 'Error',
  types: [LOG_TYPES.ERROR, LOG_TYPES.EXCEPTION, LOG_TYPES.CRASH]
}), (0, _defineProperty2.default)(_LOG_FILTER_TYPES, LOG_TYPES.INFO, {
  label: 'Info',
  filterLabel: 'Info',
  types: [LOG_TYPES.INFO]
}), (0, _defineProperty2.default)(_LOG_FILTER_TYPES, LOG_TYPES.DEBUG, {
  label: 'Debug',
  filterLabel: 'Debug',
  types: [LOG_TYPES.DEBUG]
}), (0, _defineProperty2.default)(_LOG_FILTER_TYPES, LOG_TYPES.REDUX, {
  label: 'Redux',
  types: [LOG_TYPES.REDUX]
}), (0, _defineProperty2.default)(_LOG_FILTER_TYPES, LOG_TYPES.NAVIGATION, {
  label: 'Navigation',
  types: [LOG_TYPES.NAVIGATION, LOG_TYPES.LIFECYCLE]
}), _LOG_FILTER_TYPES);
exports.LOG_FILTER_TYPES = LOG_FILTER_TYPES;

/***/ }),

/***/ "./packages/@logrocket/utils/src/constants/metrics.js":
/*!************************************************************!*\
  !*** ./packages/@logrocket/utils/src/constants/metrics.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DEFAULT_INSIGHTS_HEATMAP_FOR_URL_OPERATOR = exports.DEFAULT_HEATMAP_FOR_URL_OPERATOR = exports.nextSortDirection = exports.SORT_DIRECTION = exports.FEEDBACK_SORT_COLUMN = exports.HEATMAP_FOR_URL_OPERATOR = exports.METRIC_RETENTION_TYPE = exports.METRIC_TIMESERIES_TYPE = void 0;
var METRIC_TIMESERIES_TYPE = {
  SESSION_COUNT: 'SESSION_COUNT',
  PERCENTILE: 'PERCENTILE',
  CONVERSION_RATE: 'CONVERSION_RATE',
  SESSION_PERCENTAGE: 'SESSION_PERCENTAGE',
  ACTIVE_USERS: 'ACTIVE_USERS',
  EVENT_COUNT: 'EVENT_COUNT'
};
exports.METRIC_TIMESERIES_TYPE = METRIC_TIMESERIES_TYPE;
var METRIC_RETENTION_TYPE = {
  USER_PERCENTAGE: 'USER_PERCENTAGE'
};
exports.METRIC_RETENTION_TYPE = METRIC_RETENTION_TYPE;
var HEATMAP_FOR_URL_OPERATOR = {
  IS: 'IS',
  CONTAINS: 'CONTAINS',
  LIKE: 'LIKE',
  HREF_LIKE: 'HREF_LIKE'
};
exports.HEATMAP_FOR_URL_OPERATOR = HEATMAP_FOR_URL_OPERATOR;
var FEEDBACK_SORT_COLUMN = {
  RATING: 'RATING',
  SUBMISSION_DATE: 'SUBMISSION_DATE'
};
exports.FEEDBACK_SORT_COLUMN = FEEDBACK_SORT_COLUMN;
var SORT_DIRECTION = {
  UNSET: 'UNSET',
  ASC: 'ASC',
  DESC: 'DESC'
};
exports.SORT_DIRECTION = SORT_DIRECTION;
var nextSortDirection = function nextSortDirection(direction) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref$reverse = _ref.reverse,
    reverse = _ref$reverse === void 0 ? false : _ref$reverse;
  var UNSET = SORT_DIRECTION.UNSET,
    ASC = SORT_DIRECTION.ASC,
    DESC = SORT_DIRECTION.DESC;
  var directionOptions = [UNSET, DESC, ASC];
  if (reverse) {
    directionOptions = [UNSET, ASC, DESC];
  }
  var index = directionOptions.indexOf(direction);
  return directionOptions[(index + 1) % directionOptions.length];
};
exports.nextSortDirection = nextSortDirection;
var DEFAULT_HEATMAP_FOR_URL_OPERATOR = HEATMAP_FOR_URL_OPERATOR.IS;
exports.DEFAULT_HEATMAP_FOR_URL_OPERATOR = DEFAULT_HEATMAP_FOR_URL_OPERATOR;
var DEFAULT_INSIGHTS_HEATMAP_FOR_URL_OPERATOR = HEATMAP_FOR_URL_OPERATOR.HREF_LIKE;
exports.DEFAULT_INSIGHTS_HEATMAP_FOR_URL_OPERATOR = DEFAULT_INSIGHTS_HEATMAP_FOR_URL_OPERATOR;

/***/ }),

/***/ "./packages/@logrocket/utils/src/constants/mobile.ts":
/*!***********************************************************!*\
  !*** ./packages/@logrocket/utils/src/constants/mobile.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MAXIMUM_SUPPORTED_VERSION = exports.MINIMUM_SUPPORTED_VERSION = exports.IOS_VERSION = exports.ANDROID_VERSION = void 0;
var ANDROID_VERSION = '1.32.1';
exports.ANDROID_VERSION = ANDROID_VERSION;
var IOS_VERSION = '1.32.1';

// Inclusive
exports.IOS_VERSION = IOS_VERSION;
var MINIMUM_SUPPORTED_VERSION = '1.0.0';
// Exclusive
exports.MINIMUM_SUPPORTED_VERSION = MINIMUM_SUPPORTED_VERSION;
var MAXIMUM_SUPPORTED_VERSION = '1.33.0';
exports.MAXIMUM_SUPPORTED_VERSION = MAXIMUM_SUPPORTED_VERSION;

/***/ }),

/***/ "./packages/@logrocket/utils/src/constants/nps.js":
/*!********************************************************!*\
  !*** ./packages/@logrocket/utils/src/constants/nps.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DELIGHTED_FEEDBACK_PREFIX = exports.DELIGHTED_RESPONSES_REGEX = exports.WOOTRIC_RESPONSES_REGEX = void 0;
var WOOTRIC_RESPONSES_REGEX = /^https:\/\/production.wootric.com\/responses/;
exports.WOOTRIC_RESPONSES_REGEX = WOOTRIC_RESPONSES_REGEX;
var DELIGHTED_RESPONSES_REGEX = /^https:\/\/web.delighted.com\/e\/[a-zA-Z-]*\/c/;
exports.DELIGHTED_RESPONSES_REGEX = DELIGHTED_RESPONSES_REGEX;
var DELIGHTED_FEEDBACK_PREFIX = 'comment=';
exports.DELIGHTED_FEEDBACK_PREFIX = DELIGHTED_FEEDBACK_PREFIX;

/***/ }),

/***/ "./packages/@logrocket/utils/src/constants/platformTypes.ts":
/*!******************************************************************!*\
  !*** ./packages/@logrocket/utils/src/constants/platformTypes.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PlatformType = void 0;
var PlatformType;
exports.PlatformType = PlatformType;
(function (PlatformType) {
  PlatformType[PlatformType["UNKNOWN"] = 0] = "UNKNOWN";
  PlatformType[PlatformType["WEB"] = 1] = "WEB";
  PlatformType[PlatformType["ANDROID"] = 2] = "ANDROID";
  PlatformType[PlatformType["IOS"] = 3] = "IOS";
})(PlatformType || (exports.PlatformType = PlatformType = {}));

/***/ }),

/***/ "./packages/@logrocket/utils/src/constants/replayTypes.ts":
/*!****************************************************************!*\
  !*** ./packages/@logrocket/utils/src/constants/replayTypes.ts ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.REPLAY_TYPE = void 0;
var REPLAY_TYPE;
exports.REPLAY_TYPE = REPLAY_TYPE;
(function (REPLAY_TYPE) {
  REPLAY_TYPE["SKIA"] = "SKIA";
  REPLAY_TYPE["DOM"] = "DOM";
})(REPLAY_TYPE || (exports.REPLAY_TYPE = REPLAY_TYPE = {}));

/***/ }),

/***/ "./packages/@logrocket/utils/src/constants/sdkTypes.ts":
/*!*************************************************************!*\
  !*** ./packages/@logrocket/utils/src/constants/sdkTypes.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SESSION_TYPE_TO_DISPLAY = exports.SDK_REPLAY_TYPE = exports.SDK_TYPE_TO_DISPLAY = exports.SDK_TYPE = void 0;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));
var _replayTypes = __webpack_require__(/*! ./replayTypes */ "./packages/@logrocket/utils/src/constants/replayTypes.ts");
var _SDK_TYPE_TO_DISPLAY, _SDK_REPLAY_TYPE;
/*
  SDK_TYPE should be imported as SESSION_TYPE based on how it is being used.
  SDK_TYPE enumerates the supported sdkTypes from an ingestion/filtering perspective. sdkType is a
  session data field in ES.
  SESSION_TYPE is used to enumerate the supported sessionTypes for stripe plans, where we are
  selling and managing your quota based on the sessionType of your stripe plan.
*/
var SDK_TYPE;
exports.SDK_TYPE = SDK_TYPE;
(function (SDK_TYPE) {
  SDK_TYPE["WEB"] = "web";
  SDK_TYPE["MOBILE"] = "mobile";
  SDK_TYPE["UNKNOWN"] = "unknown";
})(SDK_TYPE || (exports.SDK_TYPE = SDK_TYPE = {}));
var SDK_TYPE_TO_DISPLAY = (_SDK_TYPE_TO_DISPLAY = {}, (0, _defineProperty2.default)(_SDK_TYPE_TO_DISPLAY, SDK_TYPE.WEB, 'Web'), (0, _defineProperty2.default)(_SDK_TYPE_TO_DISPLAY, SDK_TYPE.MOBILE, 'Mobile'), _SDK_TYPE_TO_DISPLAY);
exports.SDK_TYPE_TO_DISPLAY = SDK_TYPE_TO_DISPLAY;
var SDK_REPLAY_TYPE = (_SDK_REPLAY_TYPE = {}, (0, _defineProperty2.default)(_SDK_REPLAY_TYPE, SDK_TYPE.WEB, _replayTypes.REPLAY_TYPE.DOM), (0, _defineProperty2.default)(_SDK_REPLAY_TYPE, SDK_TYPE.MOBILE, _replayTypes.REPLAY_TYPE.SKIA), _SDK_REPLAY_TYPE);
exports.SDK_REPLAY_TYPE = SDK_REPLAY_TYPE;
var SESSION_TYPE_TO_DISPLAY = SDK_TYPE_TO_DISPLAY;
exports.SESSION_TYPE_TO_DISPLAY = SESSION_TYPE_TO_DISPLAY;

/***/ }),

/***/ "./packages/@logrocket/utils/src/constants/statusCodes.ts":
/*!****************************************************************!*\
  !*** ./packages/@logrocket/utils/src/constants/statusCodes.ts ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getStatusText = getStatusText;
exports.STATUS_CODES = void 0;
// status codes via https://developer.mozilla.org/en-US/docs/Web/HTTP/Status

var STATUS_CODES = {
  0: '',
  100: 'Continue',
  101: 'Switching Protocol',
  102: 'Processing',
  103: 'Early Hints',
  200: 'OK',
  201: 'Created',
  202: 'Accepted',
  203: 'Non-Authoritative Information',
  204: 'No Content',
  205: 'Reset Content',
  206: 'Partial Content',
  207: 'Multi-Status',
  208: 'Already Reported',
  226: 'IM Used',
  300: 'Multiple Choices',
  301: 'Moved Permanently',
  302: 'Found',
  303: 'See Other',
  304: 'Not Modified',
  305: 'Use Proxy',
  306: 'unused',
  307: 'Temporary Redirect',
  308: 'Permanent Redirect',
  400: 'Bad Request',
  401: 'Unauthorized',
  402: 'Payment Required',
  403: 'Forbidden',
  404: 'Not Found',
  405: 'Method Not Allowed',
  406: 'Not Acceptable',
  407: 'Proxy Authentication Required',
  408: 'Request Timeout',
  409: 'Conflict',
  410: 'Gone',
  411: 'Length Required',
  412: 'Precondition Failed',
  413: 'Payload Too Large',
  414: 'URI Too Long',
  415: 'Unsupported Media Type',
  416: 'Range Not Satisfiable',
  417: 'Expectation Failed',
  418: 'I\'m a teapot',
  421: 'Misdirected Request',
  422: 'Unprocessable Entity',
  423: 'Locked',
  424: 'Failed Dependency',
  425: 'Too Early',
  426: 'Upgrade Required',
  428: 'Precondition Required',
  429: 'Too Many Requests',
  431: 'Request Header Fields Too Large',
  451: 'Unavailable For Legal Reasons',
  500: 'Internal Server Error',
  501: 'Not Implemented',
  502: 'Bad Gateway',
  503: 'Service Unavailable',
  504: 'Gateway Timeout',
  505: 'HTTP Version Not Supported',
  506: 'Variant Also Negotiates',
  507: 'Insufficient Storage',
  508: 'Loop Detected',
  510: 'Not Extended',
  511: 'Network Authentication Required'
};
exports.STATUS_CODES = STATUS_CODES;
function getStatusText(statusCode) {
  return STATUS_CODES[String(statusCode)];
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/contains.js":
/*!***************************************************!*\
  !*** ./packages/@logrocket/utils/src/contains.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = contains;
function contains(value, search) {
  return value && search && value.indexOf(search) > -1;
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/deepArsonify.js":
/*!*******************************************************!*\
  !*** ./packages/@logrocket/utils/src/deepArsonify.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = deepArsonify;
var ARSON = _interopRequireWildcard(__webpack_require__(/*! @logrocket/arson */ "./packages/@logrocket/arson/src/index.js"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function deepArsonify(data) {
  return {
    // table: Arson.toTable(data).map(shallowArsonify),
    arson: ARSON.encode(data)
  };
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/deepDearsonify.js":
/*!*********************************************************!*\
  !*** ./packages/@logrocket/utils/src/deepDearsonify.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = deepDearsonify;
var ARSON = _interopRequireWildcard(__webpack_require__(/*! @logrocket/arson */ "./packages/@logrocket/arson/src/index.js"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function deepDearsonify(data) {
  if (!data) {
    return data;
  }
  return ARSON.decode(data.arson);
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/endsWith.js":
/*!***************************************************!*\
  !*** ./packages/@logrocket/utils/src/endsWith.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = endsWith;
function endsWith(value, search) {
  return value && search && value.substring(value.length - search.length) === search;
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/enhanceFunc.js":
/*!******************************************************!*\
  !*** ./packages/@logrocket/utils/src/enhanceFunc.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = enhanceFunc;
/* eslint no-param-reassign: ["error", { "props": false }] */

function enhanceFunc(obj, method, handler) {
  var original = obj[method];
  function shim() {
    var res;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (original) {
      res = original.apply(this, args);
    }
    handler.apply(this, args);
    return res;
  }
  obj[method] = shim;
  return function () {
    obj[method] = original;
  };
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/find.js":
/*!***********************************************!*\
  !*** ./packages/@logrocket/utils/src/find.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = find;
function find(array, predicate) {
  for (var idx = 0; idx < array.length; idx++) {
    if (predicate(array[idx])) {
      return array[idx];
    }
  }
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/findIndex.js":
/*!****************************************************!*\
  !*** ./packages/@logrocket/utils/src/findIndex.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = findIndex;
function findIndex(array, predicate) {
  for (var idx = 0; idx < array.length; idx++) {
    if (predicate(array[idx])) {
      return idx;
    }
  }
  return -1;
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/findKeyFrames.js":
/*!********************************************************!*\
  !*** ./packages/@logrocket/utils/src/findKeyFrames.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = findKeyFrames;
var _sortedLastIndexBy = _interopRequireDefault(__webpack_require__(/*! lodash/sortedLastIndexBy */ "./packages/@logrocket/utils/node_modules/lodash/sortedLastIndexBy.js"));
/**
 * Give an array of timed events and a time, find the array element
 * before and after that time and the progress between the frames (0 to 1)
 */
function findKeyFrames(futures, time) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
    _ref$sdkThrottle = _ref.sdkThrottle,
    sdkThrottle = _ref$sdkThrottle === void 0 ? 500 : _ref$sdkThrottle;
  if (!futures.length) {
    return null;
  }
  var index = (0, _sortedLastIndexBy.default)(futures, {
    time: time
  }, 'time');
  var next = futures[index] || futures[index - 1];
  var prev = futures[index - 1] || next;

  // Do not consider events further than `throttle` time away to be active.
  // This prevents the slow-drift effect.
  var totalTime = Math.min(next.time - prev.time, sdkThrottle);
  var expired = Math.max(time - (next.time - totalTime), 0);
  var ratio = totalTime === 0 ? 1 : Math.min(expired / totalTime, 1);
  return {
    prev: prev,
    next: next,
    ratio: ratio
  };
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/flatten.js":
/*!**************************************************!*\
  !*** ./packages/@logrocket/utils/src/flatten.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = flatten;
function flatten(acc, current) {
  return acc.concat(current);
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/getCssRules.ts":
/*!******************************************************!*\
  !*** ./packages/@logrocket/utils/src/getCssRules.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getCssRule = exports.getCssRules = void 0;
var getCssRules = function getCssRules(sheetOrRule) {
  try {
    // Chrome 64 won't let you check sheet.rules without throwing if they're unavailable
    // and Firefox uses cssRules
    var cssRules = sheetOrRule.cssRules;
    if (!cssRules && sheetOrRule instanceof CSSStyleSheet) {
      return sheetOrRule.rules;
    }
    return cssRules;
  } catch (err) {
    // catch DOMExcpetion or SecurityException from attempting to access sheetOrRule.cssRules
    //  on a cross origin hosted stylesheet.
    return null;
  }
};
exports.getCssRules = getCssRules;
var getCssRule = function getCssRule(sheetOrRule, ruleIndex) {
  var rules = getCssRules(sheetOrRule);
  if (!rules || ruleIndex >= rules.length) {
    return null;
  }
  return rules.item(ruleIndex);
};
exports.getCssRule = getCssRule;

/***/ }),

/***/ "./packages/@logrocket/utils/src/getGraphQLOperation.js":
/*!**************************************************************!*\
  !*** ./packages/@logrocket/utils/src/getGraphQLOperation.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getGraphQLOperation;
function getGraphQLOperation(body) {
  if (body) {
    try {
      var parsedBody = typeof body === 'string' ? JSON.parse(body) : body;
      var query = parsedBody.query.trim();
      var match = query.match(/(query|mutation) ([a-z_-]+)/i);
      if (!match) {
        return {};
      }
      return {
        operationType: match[1],
        operationName: match[2]
      };
    } catch (_) {
      return {};
    }
  }
  return {};
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/getNodeSelector.js":
/*!**********************************************************!*\
  !*** ./packages/@logrocket/utils/src/getNodeSelector.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _protectFunc = _interopRequireDefault(__webpack_require__(/*! ./protectFunc */ "./packages/@logrocket/utils/src/protectFunc.js"));
var getNodeSelector = (0, _protectFunc.default)(function (node) {
  // nodeName sometimes returns null
  var nodeName = node.nodeName ? node.nodeName.toLowerCase() : '';
  var selector = {
    nodeName: nodeName
  };
  if (node.id && node.id.length > 0) {
    selector.id = node.id;
  }
  if (node.classList && node.classList.length > 0) {
    selector.classList = Array.prototype.slice.call(node.classList, 0);
  }
  return selector;
});
var _default = getNodeSelector;
exports["default"] = _default;

/***/ }),

/***/ "./packages/@logrocket/utils/src/hashString.js":
/*!*****************************************************!*\
  !*** ./packages/@logrocket/utils/src/hashString.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.combineHashes = exports.hashString = void 0;
var _protectFunc = _interopRequireDefault(__webpack_require__(/*! ./protectFunc */ "./packages/@logrocket/utils/src/protectFunc.js"));
var _sendTelemetryData = __webpack_require__(/*! ./sendTelemetryData */ "./packages/@logrocket/utils/src/sendTelemetryData.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
// Java's String::hashCode
// https://devdocs.io/openjdk~8/java/lang/string#hashCode--
var hashString = (0, _protectFunc.default)(function (str) {
  try {
    var hash = 0;
    if (typeof str === 'string' && str.length) {
      for (var i = 0; i < str.length; i++) {
        hash = 31 * hash + str.charCodeAt(i);

        // Force hash to stay in a 32 bit integer so bitshifting works
        hash |= 0; // eslint-disable-line no-bitwise
      }
    }

    return hash;
  } catch (err) {
    (0, _sendTelemetryData.sendTelemetry)('Failed to hash string', {
      extra: {
        str: str
      }
    });
    return null;
  }
});

// Boost's hash_combine
exports.hashString = hashString;
var combineHashes = function combineHashes(hashes) {
  var out = hashes.shift() || 0;
  var _iterator = _createForOfIteratorHelper(hashes),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var hash = _step.value;
      out ^= hash + 0x9e3779b9 + (out << 6) + (out >> 2); // eslint-disable-line no-bitwise
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return out;
};
exports.combineHashes = combineHashes;

/***/ }),

/***/ "./packages/@logrocket/utils/src/identityStatus.ts":
/*!*********************************************************!*\
  !*** ./packages/@logrocket/utils/src/identityStatus.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.parseIdentityStatus = parseIdentityStatus;
exports.IdentityStatus = void 0;
var IdentityStatus;
exports.IdentityStatus = IdentityStatus;
(function (IdentityStatus) {
  IdentityStatus[IdentityStatus["Unknown"] = 0] = "Unknown";
  IdentityStatus[IdentityStatus["Anonymous"] = 1] = "Anonymous";
  IdentityStatus[IdentityStatus["Identified"] = 2] = "Identified";
})(IdentityStatus || (exports.IdentityStatus = IdentityStatus = {}));
function parseIdentityStatus(val) {
  if (!val) {
    return IdentityStatus.Unknown;
  }
  switch (parseInt(val, 10)) {
    case IdentityStatus.Anonymous:
      return IdentityStatus.Anonymous;
    case IdentityStatus.Identified:
      return IdentityStatus.Identified;
    default:
      return IdentityStatus.Unknown;
  }
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/index.ts":
/*!************************************************!*\
  !*** ./packages/@logrocket/utils/src/index.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var _exportNames = {
  enhanceFunc: true,
  shallowArsonify: true,
  shallowDearsonify: true,
  deepArsonify: true,
  deepDearsonify: true,
  addListener: true,
  protectFunc: true,
  findIndex: true,
  find: true,
  flatten: true,
  selectorMatches: true,
  parseSelectorForMatch: true,
  querySelectorWithShadowDom: true,
  sendErrorTelemetry: true,
  sendTelemetry: true,
  sanitizeValue: true,
  adjustOs: true,
  adjustOsVersion: true,
  selectorFromNodePath: true,
  startsWith: true,
  endsWith: true,
  contains: true,
  uuid: true,
  randomInt: true,
  getCssRules: true,
  getCssRule: true,
  getNodeSelector: true,
  getGraphQLOperation: true,
  isSessionEvent: true,
  isActivityEvent: true,
  parseIntFromHex: true,
  isRecordingSampled: true,
  makeRecordingID: true,
  setFromArray: true,
  setToArray: true,
  applyUrlSanitizer: true,
  maybeCleanSwiftUIClassName: true,
  LOG_FILTER_TYPES: true,
  LOG_TYPES: true,
  METRIC_TIMESERIES_TYPE: true,
  HEATMAP_FOR_URL_OPERATOR: true,
  DEFAULT_HEATMAP_FOR_URL_OPERATOR: true,
  DEFAULT_INSIGHTS_HEATMAP_FOR_URL_OPERATOR: true,
  SORT_DIRECTION: true,
  FEEDBACK_SORT_COLUMN: true,
  METRIC_RETENTION_TYPE: true,
  ISSUE_TYPE: true,
  ISSUE_GROUP_TYPE: true,
  ES_ISSUE_TYPE_BASE_FILTER: true,
  ES_ISSUE_TYPES: true,
  findKeyFrames: true,
  interpolate: true,
  interpolateMobile: true,
  removeOutdated: true,
  DELIGHTED_RESPONSES_REGEX: true,
  WOOTRIC_RESPONSES_REGEX: true,
  PlatformType: true,
  REPLAY_TYPE: true,
  ReplayType: true,
  SDK_REPLAY_TYPE: true,
  SDK_TYPE: true,
  SDK_TYPE_TO_DISPLAY: true,
  SESSION_TYPE_TO_DISPLAY: true,
  STATUS_CODES: true,
  getStatusText: true,
  parseQueryString: true,
  likeOperator: true,
  scrollMapHistogramToPercent: true,
  combineHashes: true,
  hashString: true,
  encodeUserTraitString: true,
  parseUserTraitString: true,
  IdentityStatus: true,
  parseIdentityStatus: true,
  scrubException: true,
  MobileConstants: true
};
Object.defineProperty(exports, "enhanceFunc", ({
  enumerable: true,
  get: function get() {
    return _enhanceFunc.default;
  }
}));
Object.defineProperty(exports, "shallowArsonify", ({
  enumerable: true,
  get: function get() {
    return _shallowArsonify.default;
  }
}));
Object.defineProperty(exports, "shallowDearsonify", ({
  enumerable: true,
  get: function get() {
    return _shallowDearsonify.default;
  }
}));
Object.defineProperty(exports, "deepArsonify", ({
  enumerable: true,
  get: function get() {
    return _deepArsonify.default;
  }
}));
Object.defineProperty(exports, "deepDearsonify", ({
  enumerable: true,
  get: function get() {
    return _deepDearsonify.default;
  }
}));
Object.defineProperty(exports, "addListener", ({
  enumerable: true,
  get: function get() {
    return _addListener.default;
  }
}));
Object.defineProperty(exports, "protectFunc", ({
  enumerable: true,
  get: function get() {
    return _protectFunc.default;
  }
}));
Object.defineProperty(exports, "findIndex", ({
  enumerable: true,
  get: function get() {
    return _findIndex.default;
  }
}));
Object.defineProperty(exports, "find", ({
  enumerable: true,
  get: function get() {
    return _find.default;
  }
}));
Object.defineProperty(exports, "flatten", ({
  enumerable: true,
  get: function get() {
    return _flatten.default;
  }
}));
Object.defineProperty(exports, "selectorMatches", ({
  enumerable: true,
  get: function get() {
    return _selectorMatches.default;
  }
}));
Object.defineProperty(exports, "parseSelectorForMatch", ({
  enumerable: true,
  get: function get() {
    return _parseSelectorForMatch.default;
  }
}));
Object.defineProperty(exports, "querySelectorWithShadowDom", ({
  enumerable: true,
  get: function get() {
    return _querySelectorWithShadowDom.default;
  }
}));
Object.defineProperty(exports, "sendErrorTelemetry", ({
  enumerable: true,
  get: function get() {
    return _sendTelemetryData.default;
  }
}));
Object.defineProperty(exports, "sendTelemetry", ({
  enumerable: true,
  get: function get() {
    return _sendTelemetryData.sendTelemetry;
  }
}));
Object.defineProperty(exports, "sanitizeValue", ({
  enumerable: true,
  get: function get() {
    return _sanitizeValue.default;
  }
}));
Object.defineProperty(exports, "adjustOs", ({
  enumerable: true,
  get: function get() {
    return _adjustOsVersion.adjustOs;
  }
}));
Object.defineProperty(exports, "adjustOsVersion", ({
  enumerable: true,
  get: function get() {
    return _adjustOsVersion.adjustOsVersion;
  }
}));
Object.defineProperty(exports, "selectorFromNodePath", ({
  enumerable: true,
  get: function get() {
    return _selectorFromNodePath.default;
  }
}));
Object.defineProperty(exports, "startsWith", ({
  enumerable: true,
  get: function get() {
    return _startsWith.default;
  }
}));
Object.defineProperty(exports, "endsWith", ({
  enumerable: true,
  get: function get() {
    return _endsWith.default;
  }
}));
Object.defineProperty(exports, "contains", ({
  enumerable: true,
  get: function get() {
    return _contains.default;
  }
}));
Object.defineProperty(exports, "uuid", ({
  enumerable: true,
  get: function get() {
    return _uuid.default;
  }
}));
Object.defineProperty(exports, "randomInt", ({
  enumerable: true,
  get: function get() {
    return _randomInt.default;
  }
}));
Object.defineProperty(exports, "getCssRules", ({
  enumerable: true,
  get: function get() {
    return _getCssRules.getCssRules;
  }
}));
Object.defineProperty(exports, "getCssRule", ({
  enumerable: true,
  get: function get() {
    return _getCssRules.getCssRule;
  }
}));
Object.defineProperty(exports, "getNodeSelector", ({
  enumerable: true,
  get: function get() {
    return _getNodeSelector.default;
  }
}));
Object.defineProperty(exports, "getGraphQLOperation", ({
  enumerable: true,
  get: function get() {
    return _getGraphQLOperation.default;
  }
}));
Object.defineProperty(exports, "isSessionEvent", ({
  enumerable: true,
  get: function get() {
    return _isSessionEvent.default;
  }
}));
Object.defineProperty(exports, "isActivityEvent", ({
  enumerable: true,
  get: function get() {
    return _isActivityEvent.default;
  }
}));
Object.defineProperty(exports, "parseIntFromHex", ({
  enumerable: true,
  get: function get() {
    return _parseIntFromHex.default;
  }
}));
Object.defineProperty(exports, "isRecordingSampled", ({
  enumerable: true,
  get: function get() {
    return _isRecordingSampled.default;
  }
}));
Object.defineProperty(exports, "makeRecordingID", ({
  enumerable: true,
  get: function get() {
    return _makeRecordingID.default;
  }
}));
Object.defineProperty(exports, "setFromArray", ({
  enumerable: true,
  get: function get() {
    return _setFromArray.default;
  }
}));
Object.defineProperty(exports, "setToArray", ({
  enumerable: true,
  get: function get() {
    return _setToArray.default;
  }
}));
Object.defineProperty(exports, "applyUrlSanitizer", ({
  enumerable: true,
  get: function get() {
    return _applyUrlSanitizer.default;
  }
}));
Object.defineProperty(exports, "maybeCleanSwiftUIClassName", ({
  enumerable: true,
  get: function get() {
    return _maybeCleanSwiftUIClassName.default;
  }
}));
Object.defineProperty(exports, "LOG_FILTER_TYPES", ({
  enumerable: true,
  get: function get() {
    return _logTypes.LOG_FILTER_TYPES;
  }
}));
Object.defineProperty(exports, "LOG_TYPES", ({
  enumerable: true,
  get: function get() {
    return _logTypes.LOG_TYPES;
  }
}));
Object.defineProperty(exports, "METRIC_TIMESERIES_TYPE", ({
  enumerable: true,
  get: function get() {
    return _metrics.METRIC_TIMESERIES_TYPE;
  }
}));
Object.defineProperty(exports, "HEATMAP_FOR_URL_OPERATOR", ({
  enumerable: true,
  get: function get() {
    return _metrics.HEATMAP_FOR_URL_OPERATOR;
  }
}));
Object.defineProperty(exports, "DEFAULT_HEATMAP_FOR_URL_OPERATOR", ({
  enumerable: true,
  get: function get() {
    return _metrics.DEFAULT_HEATMAP_FOR_URL_OPERATOR;
  }
}));
Object.defineProperty(exports, "DEFAULT_INSIGHTS_HEATMAP_FOR_URL_OPERATOR", ({
  enumerable: true,
  get: function get() {
    return _metrics.DEFAULT_INSIGHTS_HEATMAP_FOR_URL_OPERATOR;
  }
}));
Object.defineProperty(exports, "SORT_DIRECTION", ({
  enumerable: true,
  get: function get() {
    return _metrics.SORT_DIRECTION;
  }
}));
Object.defineProperty(exports, "FEEDBACK_SORT_COLUMN", ({
  enumerable: true,
  get: function get() {
    return _metrics.FEEDBACK_SORT_COLUMN;
  }
}));
Object.defineProperty(exports, "METRIC_RETENTION_TYPE", ({
  enumerable: true,
  get: function get() {
    return _metrics.METRIC_RETENTION_TYPE;
  }
}));
Object.defineProperty(exports, "ISSUE_TYPE", ({
  enumerable: true,
  get: function get() {
    return _issues.ISSUE_TYPE;
  }
}));
Object.defineProperty(exports, "ISSUE_GROUP_TYPE", ({
  enumerable: true,
  get: function get() {
    return _issues.ISSUE_GROUP_TYPE;
  }
}));
Object.defineProperty(exports, "ES_ISSUE_TYPE_BASE_FILTER", ({
  enumerable: true,
  get: function get() {
    return _issues.ES_ISSUE_TYPE_BASE_FILTER;
  }
}));
Object.defineProperty(exports, "ES_ISSUE_TYPES", ({
  enumerable: true,
  get: function get() {
    return _issues.ES_ISSUE_TYPES;
  }
}));
Object.defineProperty(exports, "findKeyFrames", ({
  enumerable: true,
  get: function get() {
    return _findKeyFrames.default;
  }
}));
Object.defineProperty(exports, "interpolate", ({
  enumerable: true,
  get: function get() {
    return _interpolate.default;
  }
}));
Object.defineProperty(exports, "interpolateMobile", ({
  enumerable: true,
  get: function get() {
    return _interpolate.interpolateMobile;
  }
}));
Object.defineProperty(exports, "removeOutdated", ({
  enumerable: true,
  get: function get() {
    return _removeOutdated.default;
  }
}));
Object.defineProperty(exports, "DELIGHTED_RESPONSES_REGEX", ({
  enumerable: true,
  get: function get() {
    return _nps.DELIGHTED_RESPONSES_REGEX;
  }
}));
Object.defineProperty(exports, "WOOTRIC_RESPONSES_REGEX", ({
  enumerable: true,
  get: function get() {
    return _nps.WOOTRIC_RESPONSES_REGEX;
  }
}));
Object.defineProperty(exports, "PlatformType", ({
  enumerable: true,
  get: function get() {
    return _platformTypes.PlatformType;
  }
}));
Object.defineProperty(exports, "REPLAY_TYPE", ({
  enumerable: true,
  get: function get() {
    return _replayTypes.REPLAY_TYPE;
  }
}));
Object.defineProperty(exports, "ReplayType", ({
  enumerable: true,
  get: function get() {
    return _replayTypes.ReplayType;
  }
}));
Object.defineProperty(exports, "SDK_REPLAY_TYPE", ({
  enumerable: true,
  get: function get() {
    return _sdkTypes.SDK_REPLAY_TYPE;
  }
}));
Object.defineProperty(exports, "SDK_TYPE", ({
  enumerable: true,
  get: function get() {
    return _sdkTypes.SDK_TYPE;
  }
}));
Object.defineProperty(exports, "SDK_TYPE_TO_DISPLAY", ({
  enumerable: true,
  get: function get() {
    return _sdkTypes.SDK_TYPE_TO_DISPLAY;
  }
}));
Object.defineProperty(exports, "SESSION_TYPE_TO_DISPLAY", ({
  enumerable: true,
  get: function get() {
    return _sdkTypes.SESSION_TYPE_TO_DISPLAY;
  }
}));
Object.defineProperty(exports, "STATUS_CODES", ({
  enumerable: true,
  get: function get() {
    return _statusCodes.STATUS_CODES;
  }
}));
Object.defineProperty(exports, "getStatusText", ({
  enumerable: true,
  get: function get() {
    return _statusCodes.getStatusText;
  }
}));
Object.defineProperty(exports, "parseQueryString", ({
  enumerable: true,
  get: function get() {
    return _parseQueryString.parseQueryString;
  }
}));
Object.defineProperty(exports, "likeOperator", ({
  enumerable: true,
  get: function get() {
    return _likeOperator.likeOperator;
  }
}));
Object.defineProperty(exports, "scrollMapHistogramToPercent", ({
  enumerable: true,
  get: function get() {
    return _scrollMapHistogramToPercent.default;
  }
}));
Object.defineProperty(exports, "combineHashes", ({
  enumerable: true,
  get: function get() {
    return _hashString.combineHashes;
  }
}));
Object.defineProperty(exports, "hashString", ({
  enumerable: true,
  get: function get() {
    return _hashString.hashString;
  }
}));
Object.defineProperty(exports, "encodeUserTraitString", ({
  enumerable: true,
  get: function get() {
    return _userTraitStrings.encodeUserTraitString;
  }
}));
Object.defineProperty(exports, "parseUserTraitString", ({
  enumerable: true,
  get: function get() {
    return _userTraitStrings.parseUserTraitString;
  }
}));
Object.defineProperty(exports, "IdentityStatus", ({
  enumerable: true,
  get: function get() {
    return _identityStatus.IdentityStatus;
  }
}));
Object.defineProperty(exports, "parseIdentityStatus", ({
  enumerable: true,
  get: function get() {
    return _identityStatus.parseIdentityStatus;
  }
}));
Object.defineProperty(exports, "scrubException", ({
  enumerable: true,
  get: function get() {
    return _scrubException.scrubException;
  }
}));
exports.MobileConstants = void 0;
var _enhanceFunc = _interopRequireDefault(__webpack_require__(/*! ./enhanceFunc */ "./packages/@logrocket/utils/src/enhanceFunc.js"));
var _shallowArsonify = _interopRequireDefault(__webpack_require__(/*! ./shallowArsonify */ "./packages/@logrocket/utils/src/shallowArsonify.js"));
var _shallowDearsonify = _interopRequireDefault(__webpack_require__(/*! ./shallowDearsonify */ "./packages/@logrocket/utils/src/shallowDearsonify.js"));
var _deepArsonify = _interopRequireDefault(__webpack_require__(/*! ./deepArsonify */ "./packages/@logrocket/utils/src/deepArsonify.js"));
var _deepDearsonify = _interopRequireDefault(__webpack_require__(/*! ./deepDearsonify */ "./packages/@logrocket/utils/src/deepDearsonify.js"));
var _addListener = _interopRequireDefault(__webpack_require__(/*! ./addListener */ "./packages/@logrocket/utils/src/addListener.js"));
var _protectFunc = _interopRequireDefault(__webpack_require__(/*! ./protectFunc */ "./packages/@logrocket/utils/src/protectFunc.js"));
var _findIndex = _interopRequireDefault(__webpack_require__(/*! ./findIndex */ "./packages/@logrocket/utils/src/findIndex.js"));
var _find = _interopRequireDefault(__webpack_require__(/*! ./find */ "./packages/@logrocket/utils/src/find.js"));
var _flatten = _interopRequireDefault(__webpack_require__(/*! ./flatten */ "./packages/@logrocket/utils/src/flatten.js"));
var _selectorMatches = _interopRequireDefault(__webpack_require__(/*! ./selectorMatches */ "./packages/@logrocket/utils/src/selectorMatches.js"));
var _parseSelectorForMatch = _interopRequireDefault(__webpack_require__(/*! ./parseSelectorForMatch */ "./packages/@logrocket/utils/src/parseSelectorForMatch.js"));
var _querySelectorWithShadowDom = _interopRequireDefault(__webpack_require__(/*! ./querySelectorWithShadowDom */ "./packages/@logrocket/utils/src/querySelectorWithShadowDom.js"));
var _sendTelemetryData = _interopRequireWildcard(__webpack_require__(/*! ./sendTelemetryData */ "./packages/@logrocket/utils/src/sendTelemetryData.js"));
var _sanitizeValue = _interopRequireDefault(__webpack_require__(/*! ./sanitizeValue */ "./packages/@logrocket/utils/src/sanitizeValue.js"));
var _adjustOsVersion = __webpack_require__(/*! ./adjustOsVersion */ "./packages/@logrocket/utils/src/adjustOsVersion.ts");
var _selectorFromNodePath = _interopRequireDefault(__webpack_require__(/*! ./selectorFromNodePath */ "./packages/@logrocket/utils/src/selectorFromNodePath.js"));
var _startsWith = _interopRequireDefault(__webpack_require__(/*! ./startsWith */ "./packages/@logrocket/utils/src/startsWith.js"));
var _endsWith = _interopRequireDefault(__webpack_require__(/*! ./endsWith */ "./packages/@logrocket/utils/src/endsWith.js"));
var _contains = _interopRequireDefault(__webpack_require__(/*! ./contains */ "./packages/@logrocket/utils/src/contains.js"));
var _uuid = _interopRequireDefault(__webpack_require__(/*! ./uuid */ "./packages/@logrocket/utils/src/uuid.js"));
var _randomInt = _interopRequireDefault(__webpack_require__(/*! ./randomInt */ "./packages/@logrocket/utils/src/randomInt.js"));
var _getCssRules = __webpack_require__(/*! ./getCssRules */ "./packages/@logrocket/utils/src/getCssRules.ts");
var _getNodeSelector = _interopRequireDefault(__webpack_require__(/*! ./getNodeSelector */ "./packages/@logrocket/utils/src/getNodeSelector.js"));
var _getGraphQLOperation = _interopRequireDefault(__webpack_require__(/*! ./getGraphQLOperation */ "./packages/@logrocket/utils/src/getGraphQLOperation.js"));
var _isSessionEvent = _interopRequireDefault(__webpack_require__(/*! ./isSessionEvent */ "./packages/@logrocket/utils/src/isSessionEvent.js"));
var _isActivityEvent = _interopRequireDefault(__webpack_require__(/*! ./isActivityEvent */ "./packages/@logrocket/utils/src/isActivityEvent.js"));
var _parseIntFromHex = _interopRequireDefault(__webpack_require__(/*! ./parseIntFromHex */ "./packages/@logrocket/utils/src/parseIntFromHex.js"));
var _isRecordingSampled = _interopRequireDefault(__webpack_require__(/*! ./isRecordingSampled */ "./packages/@logrocket/utils/src/isRecordingSampled.js"));
var _makeRecordingID = _interopRequireDefault(__webpack_require__(/*! ./makeRecordingID */ "./packages/@logrocket/utils/src/makeRecordingID.js"));
var _setFromArray = _interopRequireDefault(__webpack_require__(/*! ./setFromArray */ "./packages/@logrocket/utils/src/setFromArray.js"));
var _setToArray = _interopRequireDefault(__webpack_require__(/*! ./setToArray */ "./packages/@logrocket/utils/src/setToArray.js"));
var _applyUrlSanitizer = _interopRequireDefault(__webpack_require__(/*! ./applyUrlSanitizer */ "./packages/@logrocket/utils/src/applyUrlSanitizer.js"));
var _maybeCleanSwiftUIClassName = _interopRequireDefault(__webpack_require__(/*! ./maybeCleanSwiftUIClassName */ "./packages/@logrocket/utils/src/maybeCleanSwiftUIClassName.ts"));
var _logTypes = __webpack_require__(/*! ./constants/logTypes */ "./packages/@logrocket/utils/src/constants/logTypes.js");
var _metrics = __webpack_require__(/*! ./constants/metrics */ "./packages/@logrocket/utils/src/constants/metrics.js");
var _issues = __webpack_require__(/*! ./constants/issues */ "./packages/@logrocket/utils/src/constants/issues.ts");
var _findKeyFrames = _interopRequireDefault(__webpack_require__(/*! ./findKeyFrames */ "./packages/@logrocket/utils/src/findKeyFrames.js"));
var _interpolate = _interopRequireWildcard(__webpack_require__(/*! ./interpolate */ "./packages/@logrocket/utils/src/interpolate.js"));
var _removeOutdated = _interopRequireDefault(__webpack_require__(/*! ./removeOutdated */ "./packages/@logrocket/utils/src/removeOutdated.js"));
var _nps = __webpack_require__(/*! ./constants/nps */ "./packages/@logrocket/utils/src/constants/nps.js");
var _platformTypes = __webpack_require__(/*! ./constants/platformTypes */ "./packages/@logrocket/utils/src/constants/platformTypes.ts");
var _replayTypes = __webpack_require__(/*! ./constants/replayTypes */ "./packages/@logrocket/utils/src/constants/replayTypes.ts");
var _sdkTypes = __webpack_require__(/*! ./constants/sdkTypes */ "./packages/@logrocket/utils/src/constants/sdkTypes.ts");
var _statusCodes = __webpack_require__(/*! ./constants/statusCodes */ "./packages/@logrocket/utils/src/constants/statusCodes.ts");
var _parseQueryString = __webpack_require__(/*! ./parseQueryString */ "./packages/@logrocket/utils/src/parseQueryString.js");
var _likeOperator = __webpack_require__(/*! ./likeOperator */ "./packages/@logrocket/utils/src/likeOperator.js");
var _scrollMapHistogramToPercent = _interopRequireDefault(__webpack_require__(/*! ./scrollMapHistogramToPercent */ "./packages/@logrocket/utils/src/scrollMapHistogramToPercent.js"));
var _hashString = __webpack_require__(/*! ./hashString */ "./packages/@logrocket/utils/src/hashString.js");
var _userTraitStrings = __webpack_require__(/*! ./userTraitStrings */ "./packages/@logrocket/utils/src/userTraitStrings.ts");
var _identityStatus = __webpack_require__(/*! ./identityStatus */ "./packages/@logrocket/utils/src/identityStatus.ts");
var _scrubException = __webpack_require__(/*! ./scrubException */ "./packages/@logrocket/utils/src/scrubException.ts");
var _MobileConstants = _interopRequireWildcard(__webpack_require__(/*! ./constants/mobile */ "./packages/@logrocket/utils/src/constants/mobile.ts"));
exports.MobileConstants = _MobileConstants;
var _browserUtils = __webpack_require__(/*! ./browserUtils */ "./packages/@logrocket/utils/src/browserUtils.js");
Object.keys(_browserUtils).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _browserUtils[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _browserUtils[key];
    }
  });
});
var _isValidAppID = __webpack_require__(/*! ./isValidAppID */ "./packages/@logrocket/utils/src/isValidAppID.ts");
Object.keys(_isValidAppID).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _isValidAppID[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _isValidAppID[key];
    }
  });
});
var _requireValue = __webpack_require__(/*! ./requireValue */ "./packages/@logrocket/utils/src/requireValue.ts");
Object.keys(_requireValue).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _requireValue[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _requireValue[key];
    }
  });
});
var _types = __webpack_require__(/*! ./types */ "./packages/@logrocket/utils/src/types.ts");
Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _types[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _types[key];
    }
  });
});
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/***/ }),

/***/ "./packages/@logrocket/utils/src/interpolate.js":
/*!******************************************************!*\
  !*** ./packages/@logrocket/utils/src/interpolate.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = interpolate;
exports.interpolateMobile = interpolateMobile;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function interpolate(keyFrames, props) {
  if (!keyFrames) {
    return {};
  }
  var prev = keyFrames.prev,
    next = keyFrames.next,
    ratio = keyFrames.ratio;
  var mid = _objectSpread({}, next);
  var _iterator = _createForOfIteratorHelper(props),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var p = _step.value;
      mid[p] = prev[p] + (next[p] - prev[p]) * ratio;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return mid;
}
function interpolateMobile(keyFrames, props, time) {
  if (!keyFrames) {
    return {};
  }
  var prev = keyFrames.prev,
    next = keyFrames.next;
  if (next.type === 'MOVE') {
    return interpolate(keyFrames, props);
  }

  // let touch events only linger for half a second on the screen
  if (prev === next && Math.abs(time - next.time) > 500) {
    return null;
  }
  return next;
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/isActivityEvent.js":
/*!**********************************************************!*\
  !*** ./packages/@logrocket/utils/src/isActivityEvent.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isActivityEvent;
function isActivityEvent(type) {
  var activityTypes = ['lr.browser.MouseEvent', 'lr.browser.ScrollEvent', 'lr.browser.InputEvent', 'lr.browser.InputChangeEvent', 'lr.android.TouchEvent', 'lr.android.InputChangeEvent', 'lr.ios.TouchEvent', 'lr.ios.InputChangeEvent'];
  return activityTypes.indexOf(type) > -1;
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/isRecordingSampled.js":
/*!*************************************************************!*\
  !*** ./packages/@logrocket/utils/src/isRecordingSampled.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isRecordingSampled;
var _parseIntFromHex = _interopRequireDefault(__webpack_require__(/*! ./parseIntFromHex */ "./packages/@logrocket/utils/src/parseIntFromHex.js"));
var SAMPLE_BUCKETS = 10000; // As few as 0.01% of recordings

function isRecordingSampled(recordingID, samplePercent) {
  if (samplePercent <= 0) {
    return false;
  }
  var maxBucket = Math.floor(samplePercent * SAMPLE_BUCKETS);
  var num = (0, _parseIntFromHex.default)(recordingID);
  var bucket = num % SAMPLE_BUCKETS;
  return bucket <= maxBucket;
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/isSessionEvent.js":
/*!*********************************************************!*\
  !*** ./packages/@logrocket/utils/src/isSessionEvent.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isSessionEvent;
var SESSION_EVENT_WHITELIST = ['lr.browser.NavigationEvent', 'lr.browser.InputChangeEvent', 'lr.browser.InputEvent'];
function isSessionEvent(event) {
  return SESSION_EVENT_WHITELIST.indexOf(event.type) > -1 || event.data.eventType === 'CLICK';
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/isValidAppID.ts":
/*!*******************************************************!*\
  !*** ./packages/@logrocket/utils/src/isValidAppID.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isValidAppID = isValidAppID;
// This pattern matches the orgSlug/appSlug format we expect for appIDs. Each slug is generated using the `slugify`
// helper which performs a few conversions:
// 1) All unicode is converted to approximate ASCII, or removed if there is no replacement.
// 2) Spaces are converted to hyphens
// 3) Remove any characters that are not alphanumeric, a hyphen, or an underscore.
// 4) And finally, lowercase the string.
//
// https://docs.djangoproject.com/en/1.10/_modules/django/utils/text/#slugify
//
// The fields storing these slugs are SlugField instances, which use a different validation regex allowing uppercase
// characters. As the final step in `slugify` is to lowercase all text, and that is how we generate slugs, we do not
// consider uppercase characters valid in an appID.
//
// https://docs.djangoproject.com/en/1.10/_modules/django/core/validators/ (see slug_re)
var APP_ID_PATTERN = /^[a-z0-9_-]+\/[a-z0-9_-]+$/;
function isValidAppID(appID) {
  return typeof appID === 'string' && APP_ID_PATTERN.test(appID);
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/likeOperator.js":
/*!*******************************************************!*\
  !*** ./packages/@logrocket/utils/src/likeOperator.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.likeOperator = likeOperator;
function likeOperator(value, pattern) {
  // Behaves like the ES "wildcard" query
  // (See: https://www.elastic.co/guide/en/elasticsearch/reference/6.5/query-dsl-wildcard-query.html#query-dsl-wildcard-query)

  var escaped = pattern.replace(
  // (See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping)
  /[.*+?^${}()|[\]\\]/g, '\\$&');

  // To emulate the ES wildcard search in regex
  // (a) prefix '*' with the regex wildcard '.' character
  // (c) convert '?' to '.'
  // Keep in mind that we have escaped these characters, so we actually need to match
  // their escaped versions.
  var escapedRegexString = escaped.replace(/\\\*/g, '.*').replace(/\\\?/g, '.');
  var regex = new RegExp("^".concat(escapedRegexString, "$"));
  return regex.test(value);
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/logError.js":
/*!***************************************************!*\
  !*** ./packages/@logrocket/utils/src/logError.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var canBind = typeof console !== 'undefined' && console.error && console.error.bind;
var logError = canBind ? console.error.bind(console) : function () {};
var _default = logError;
exports["default"] = _default;

/***/ }),

/***/ "./packages/@logrocket/utils/src/makeRecordingID.js":
/*!**********************************************************!*\
  !*** ./packages/@logrocket/utils/src/makeRecordingID.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = makeRecordingID;
var _uuid = _interopRequireDefault(__webpack_require__(/*! ./uuid */ "./packages/@logrocket/utils/src/uuid.js"));
function makeRecordingID() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    _ref$prefix = _ref.prefix,
    prefix = _ref$prefix === void 0 ? 5 : _ref$prefix;
  return "".concat(prefix, "-").concat((0, _uuid.default)());
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/mapValues.js":
/*!****************************************************!*\
  !*** ./packages/@logrocket/utils/src/mapValues.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = mapValues;
function mapValues(obj, f) {
  if (obj == null) {
    return {};
  }
  var res = {};
  Object.keys(obj).forEach(function (key) {
    res[key] = f(obj[key]);
  });
  return res;
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/maybeCleanSwiftUIClassName.ts":
/*!*********************************************************************!*\
  !*** ./packages/@logrocket/utils/src/maybeCleanSwiftUIClassName.ts ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = maybeCleanSwiftUIClassName;
function maybeCleanSwiftUIClassName(className) {
  // replace angle brackets present in SwiftUI ViewController type strings with ascii encoding and strip spaces
  return className ? className.replace(/</g, '%3c').replace(/>/g, '%3e').replace(/\s/g, '') : '';
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/parseIntFromHex.js":
/*!**********************************************************!*\
  !*** ./packages/@logrocket/utils/src/parseIntFromHex.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = parseIntFromHex;
function parseIntFromHex(string) {
  // strip non-hex characters
  var hex = string.replace(/[^0-9a-f]/g, '');
  return parseInt("0x".concat(hex), 16) || 0;
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/parseQueryString.js":
/*!***********************************************************!*\
  !*** ./packages/@logrocket/utils/src/parseQueryString.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.parseQueryString = void 0;
var _slicedToArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js"));
var parseSearchParams = function parseSearchParams(queryString) {
  // Ideally this would use URLSearchParams but that's unsupported in IE 11
  var params = {};
  var fragments = queryString.split('&');
  // The way this is constructed will take the last of any duplicate keys
  fragments.forEach(function (fragment) {
    var _fragment$split$map$m = fragment.split('=')
      // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent#decoding_query_parameters_from_a_url
      .map(function (s) {
        return s.replace(/\+/g, ' ');
      }).map(decodeURIComponent),
      _fragment$split$map$m2 = (0, _slicedToArray2.default)(_fragment$split$map$m, 2),
      key = _fragment$split$map$m2[0],
      value = _fragment$split$map$m2[1];
    params[key] = value;
  });
  return params;
};

/**
 * Parse a full URL into an object with keys and values for parameters in the query
 * string of the URL.
 */
var parseQueryString = function parseQueryString(href) {
  var queryDelimiterIndex = href.indexOf('?');
  if (queryDelimiterIndex === -1) {
    return {};
  }

  // Strip the leading '?'
  var queryString = href.substring(queryDelimiterIndex + 1);
  return parseSearchParams(queryString);
};
exports.parseQueryString = parseQueryString;

/***/ }),

/***/ "./packages/@logrocket/utils/src/parseSelectorForMatch.js":
/*!****************************************************************!*\
  !*** ./packages/@logrocket/utils/src/parseSelectorForMatch.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = parseSelectorForMatch;
var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js"));
var _slicedToArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js"));
var _startsWith = _interopRequireDefault(__webpack_require__(/*! ./startsWith */ "./packages/@logrocket/utils/src/startsWith.js"));
var nthChildDelim = '~';
var nthChildPrefix = ':nth-child(';

// parses selectorString into an array of node objects identifying the following attributes:
// id: <String>, classNames: [<String>], nodeName: <String>, directDesc: <Bool>, nthChild: <String>
function parseSelectorForMatch(selectorString) {
  var parsedStr = selectorString.replace(/\s*>\s*|:nth-child\(([1-9][0-9]*|odd|even)\)|\s+/gi, function (match) {
    if (match.indexOf('>') > -1) {
      return ' >';
    }
    if (match.trim().length === 0) {
      return ' ';
    }
    return "".concat(nthChildDelim).concat(match.slice(nthChildPrefix.length));
  });
  return parsedStr.split(/\s+/).map(function (nodeString) {
    var nodeObject = {};
    var cleanNodeString = nodeString;
    if (cleanNodeString.charAt(0) === '>') {
      nodeObject.directDesc = true;
      cleanNodeString = cleanNodeString.slice(1);
    }
    cleanNodeString = cleanNodeString.replace(/^([a-z0-9-_]+)/ig, function (match) {
      nodeObject.nodeName = match;
      return '';
    });
    if (cleanNodeString.charAt(0) === nthChildDelim) {
      var _cleanNodeString$slic = cleanNodeString.slice(1).split(')'),
        _cleanNodeString$slic2 = (0, _slicedToArray2.default)(_cleanNodeString$slic, 2),
        childID = _cleanNodeString$slic2[0],
        rest = _cleanNodeString$slic2[1];
      nodeObject.nthChild = childID;
      cleanNodeString = rest;
    }
    cleanNodeString.replace(/\.|#/gi, function (match) {
      return " ".concat(match);
    }).trim().split(' ').forEach(function (nodePart) {
      if ((0, _startsWith.default)(nodePart, '.')) {
        var className = nodePart.slice(1);
        nodeObject.classList = nodeObject.classList ? [].concat((0, _toConsumableArray2.default)(nodeObject.classList), [className]) : [className];
      } else if ((0, _startsWith.default)(nodePart, '#')) {
        nodeObject.id = nodePart.slice(1);
      }
    });
    return nodeObject;
  });
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/protectFunc.js":
/*!******************************************************!*\
  !*** ./packages/@logrocket/utils/src/protectFunc.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = protectFunc;
var _sendTelemetryData = _interopRequireDefault(__webpack_require__(/*! ./sendTelemetryData */ "./packages/@logrocket/utils/src/sendTelemetryData.js"));
var _logError = _interopRequireDefault(__webpack_require__(/*! ./logError */ "./packages/@logrocket/utils/src/logError.js"));
function protectFunc(f) {
  var onFail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
  return function () {
    var result;
    try {
      result = f.apply(void 0, arguments);
    } catch (err) {
      if (typeof window !== 'undefined' && window._lrdebug) {
        throw err;
      }
      var payload = onFail(err);
      (0, _logError.default)('LogRocket', err);
      (0, _sendTelemetryData.default)(err, payload);
    }
    return result;
  };
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/querySelectorWithShadowDom.js":
/*!*********************************************************************!*\
  !*** ./packages/@logrocket/utils/src/querySelectorWithShadowDom.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = querySelectorWithShadowDom;
exports.caseInsensitiveQuerySelector = void 0;
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var getMatchingChildren = function getMatchingChildren(_ref) {
  var root = _ref.root,
    selectorList = _ref.selectorList,
    directDesc = _ref.directDesc;
  var selectorParts = selectorList[0].split(/(?=\.)|(?=#)/);

  // element selector looks like "type:nth-child(x)"
  var elementSelector = selectorParts.shift();
  var id = '';
  var classes = [];
  selectorParts.forEach(function (part) {
    if (part[0] === '#') {
      id = part.toLowerCase().substring(1).trim();
    }
    if (part[0] === '.') {
      classes.push(part.toLowerCase().substring(1).trim());
    }
  });
  var matchingElements;
  if (directDesc) {
    matchingElements = [root.querySelector(":scope > ".concat(elementSelector))];
  } else {
    matchingElements = root.querySelectorAll(elementSelector);
  }
  var matches = [];
  // check each matched elements for a full match
  var _iterator = _createForOfIteratorHelper(matchingElements),
    _step;
  try {
    var _loop = function _loop() {
      var currentMatch = _step.value;
      if (!currentMatch || id !== currentMatch.id.toLowerCase()) {
        return "continue";
      }
      var currentClasses = Array.from(currentMatch.classList.values()).map(function (c) {
        return c.toLowerCase();
      }).filter(function (s) {
        return s !== '' && s[0] !== ':';
      }); // no pseudo classes or empties

      if (!classes.every(function (v) {
        return currentClasses.indexOf(v) > -1;
      })) {
        return "continue";
      }
      matches.push(currentMatch);
    };
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _ret = _loop();
      if (_ret === "continue") continue;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return matches;
};

// The parser expects the selector to be formatted as an ES mouse click selector:

// div:nth-child(1)#some-id > div:nth-child(1)#id-me.class1.class2 > div:nth-child(3) > ...

// with the given selector format it will return the same result as
// root.querySelector(selector) without case sensitivity
var caseInsensitiveQuerySelector = function caseInsensitiveQuerySelector(root, selector) {
  if (!selector.length) {
    return null;
  }

  // If root is part of a shadow DOM, start from the shadow root. Otherwise,
  //  root must start at body element to protect against malformed DOMs:
  var rootElement;
  if (root.host) {
    // The presence of root.host indicates a shadow root:
    rootElement = root;
  } else {
    rootElement = root.querySelector('body');
  }

  // no shadow dom root or body tag
  if (!rootElement) {
    return null;
  }

  // when storing selectors we truncate the leading segments of long selector strings
  // this makes the first selector segment possibly anywhere in the DOM
  var queue = [{
    matches: [rootElement],
    selectorList: selector.split(' > '),
    directDesc: false
  }];
  while (queue.length) {
    var _queue$shift = queue.shift(),
      matches = _queue$shift.matches,
      selectorList = _queue$shift.selectorList,
      directDesc = _queue$shift.directDesc;
    var _iterator2 = _createForOfIteratorHelper(matches),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var matchedElement = _step2.value;
        var currentMatches = getMatchingChildren({
          root: matchedElement,
          selectorList: selectorList,
          directDesc: directDesc
        });

        // did I find it?
        if (currentMatches.length && selectorList.length === 1) {
          return currentMatches[0];
        }
        if (currentMatches.length) {
          queue.push({
            matches: currentMatches,
            selectorList: selectorList.slice(1),
            directDesc: true // all segments after the first must be direct descendants
          });
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  return null;
};
exports.caseInsensitiveQuerySelector = caseInsensitiveQuerySelector;
function querySelectorWithShadowDom(element, fullSelector) {
  if (fullSelector.startsWith('$shadow-root >')) {
    throw new Error("Malformed selector '".concat(fullSelector, "': should not start with $shadow-root"));
  }
  if (fullSelector.endsWith('> $shadow-root')) {
    // Selector ends in an empty shadow root; remove it so we don't perform an invalid query:
    // eslint-disable-next-line no-param-reassign
    fullSelector = fullSelector.slice(0, fullSelector.length - '> $shadow-root'.length);
  }
  var currentRoot = element;
  var currentNode;
  var selectors = fullSelector.split('> $shadow-root >');
  for (var i = 0; i < selectors.length; i++) {
    currentNode = caseInsensitiveQuerySelector(currentRoot, selectors[i]);

    // Dive into the shadow!
    if (currentNode && i < selectors.length - 1) {
      if (currentNode.shadowRoot) {
        currentRoot = currentNode.shadowRoot;
      } else {
        throw new Error("Missing shadowRoot for selector '".concat(fullSelector, "' at depth ").concat(i));
      }
    }
  }
  return {
    root: currentRoot,
    node: currentNode
  };
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/randomInt.js":
/*!****************************************************!*\
  !*** ./packages/@logrocket/utils/src/randomInt.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = randomInt;
// min is inclusive, max is exclusive
function randomInt(min, max) {
  var minInt = Math.ceil(min);
  var maxInt = Math.floor(max);
  return Math.floor(Math.random() * (maxInt - minInt)) + minInt;
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/removeOutdated.js":
/*!*********************************************************!*\
  !*** ./packages/@logrocket/utils/src/removeOutdated.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = removeOutdated;
var _sortedLastIndexBy = _interopRequireDefault(__webpack_require__(/*! lodash/sortedLastIndexBy */ "./packages/@logrocket/utils/node_modules/lodash/sortedLastIndexBy.js"));
var KEEP = 5000;
function removeOutdated(state, action) {
  if (state.length === 0) {
    return state;
  }

  // Find the first entry which is **before** the given actions time.
  var index = (0, _sortedLastIndexBy.default)(state, {
    time: action.time - KEEP
  }, 'time') - 1;
  var first = state[index];

  // Keep one entry that is more than KEEP away, and remove the rest of them.
  if (first && action.time - first.time > KEEP && index > 0) {
    return state.slice(index);
  }
  return state;
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/requireValue.ts":
/*!*******************************************************!*\
  !*** ./packages/@logrocket/utils/src/requireValue.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.requireValue = void 0;
var requireValue = function requireValue(value) {
  if (typeof value === 'undefined') {
    throw new Error('Value must not be undefined.');
  }
  return value;
};
exports.requireValue = requireValue;

/***/ }),

/***/ "./packages/@logrocket/utils/src/sanitizeValue.js":
/*!********************************************************!*\
  !*** ./packages/@logrocket/utils/src/sanitizeValue.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = sanitizeValue;
var _replaceWithLipsum = function _replaceWithLipsum(content) {
  // eslint-disable-next-line max-len
  var lipsum = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. ';
  var repeatLength = Math.ceil(content.length / lipsum.length);
  var replacementContent = '';
  while (repeatLength > 0) {
    replacementContent += lipsum;
    repeatLength--;
  }
  return replacementContent.slice(0, content.length);
};
function sanitizeValue(valueToClean, taintType) {
  var value = String(valueToClean);
  if (String(taintType).toLowerCase() === 'lipsum') {
    return _replaceWithLipsum(value);
  }
  return '';
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/scrollMapHistogramToPercent.js":
/*!**********************************************************************!*\
  !*** ./packages/@logrocket/utils/src/scrollMapHistogramToPercent.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = scrollMapHistogramToPercent;
function scrollMapHistogramToPercent(buckets, scrollHeight) {
  var scrollMap = [];
  var currentSessionCount = buckets.reduce(function (acc, d) {
    return acc + d.count;
  }, 0);
  var cursor = 0;
  for (var p = 1; p <= 100; p++) {
    var containerPosition = scrollHeight * (p * 0.01);
    if (cursor >= buckets.length) {
      scrollMap.push(0); // beyond scrolled area has 0 sessions
    } else {
      scrollMap.push(currentSessionCount);
      if (containerPosition > buckets[cursor].maxScroll) {
        currentSessionCount -= buckets[cursor].count;
        cursor++;
      }
    }
  }
  return scrollMap;
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/scrubException.ts":
/*!*********************************************************!*\
  !*** ./packages/@logrocket/utils/src/scrubException.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.scrubException = scrubException;
var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function isScalar(value) {
  return /boolean|number|string/.test((0, _typeof2.default)(value));
}
var optionalScalars = [
// Valid values for 'level' are 'fatal', 'error', 'warning', 'info',
// and 'debug'. Defaults to 'error'.
'level', 'logger'];
var optionalMaps = ['tags', 'extra'];
function scrubException(data, options) {
  if (options) {
    var _iterator = _createForOfIteratorHelper(optionalScalars),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var field = _step.value;
        var value = options[field];
        if (isScalar(value)) {
          // eslint-disable-next-line no-param-reassign
          data[field] = value.toString();
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _iterator2 = _createForOfIteratorHelper(optionalMaps),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _field = _step2.value;
        var dirty = options[_field] || {};
        var scrubbed = {};
        for (var _i = 0, _Object$keys = Object.keys(dirty); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];
          var _value = dirty[key];
          if (isScalar(_value)) {
            scrubbed[key.toString()] = _value.toString();
          }
        }

        // eslint-disable-next-line no-param-reassign
        data[_field] = scrubbed;
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/selectorFromNodePath.js":
/*!***************************************************************!*\
  !*** ./packages/@logrocket/utils/src/selectorFromNodePath.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = selectorFromNodePath;
var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function selectorFromNodePath() {
  var nodePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var selectors = [];
  // NodePaths are { nodeName: String, classList: [String], id: String }
  var _iterator = _createForOfIteratorHelper((0, _toConsumableArray2.default)(nodePath).reverse()),
    _step;
  try {
    var _loop = function _loop() {
      var path = _step.value;
      var nodeName = path.nodeName,
        id = path.id,
        nthChild = path.nthChild;
      var classList = path.classList;
      var selectorParts = [];

      // pseudo classes
      var pseudoClassList = [];
      nthChild && pseudoClassList.push("nth-child(".concat(nthChild, ")"));
      // ... more as we decide to support them

      if (nodeName) {
        selectorParts.push(nodeName);
        pseudoClassList.sort().map(function (pseudoClass) {
          return selectorParts.push(":".concat(pseudoClass));
        });
      }
      if (id) {
        selectorParts.push("#".concat(id.replaceAll('.', '\\.')));
      }
      if (classList && classList.length) {
        classList = classList.map(function (value) {
          return value.toLowerCase();
        }).sort();
        selectorParts = [].concat((0, _toConsumableArray2.default)(selectorParts), (0, _toConsumableArray2.default)(classList.map(function (className) {
          return ".".concat(className.replaceAll('.', '\\.'));
        })));
      }
      if (selectorParts.length) {
        selectors.push(selectorParts.join(' '));
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return selectors.join(' > ');
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/selectorMatches.js":
/*!**********************************************************!*\
  !*** ./packages/@logrocket/utils/src/selectorMatches.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = selectorMatches;
var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js"));
var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));
var _findIndex = _interopRequireDefault(__webpack_require__(/*! ./findIndex */ "./packages/@logrocket/utils/src/findIndex.js"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
// checks that nodeB fulfills all requirements specified in nodeA
function nodesMatch(nodeA, nodeB) {
  if (!(nodeA && nodeB)) {
    return false;
  }
  if (nodeA.id && nodeA.id !== nodeB.id) {
    return false;
  }
  if (nodeA.nodeName && nodeA.nodeName !== nodeB.nodeName) {
    return false;
  }
  if (nodeA.classList && (!nodeB.classList || nodeA.classList.map(function (classNameA) {
    return classNameA.toLowerCase();
  }).some(function (classNameA) {
    return nodeB.classList.map(function (classNameB) {
      return classNameB.toLowerCase();
    }).indexOf(classNameA) === -1;
  }))) {
    return false;
  }
  if (nodeA.nthChild) {
    var parsed = parseInt(nodeA.nthChild, 10);
    if (isNaN(parsed)) {
      return Math.abs(nodeB.nthChild % 2) === (nodeA.nthChild === 'odd' ? 1 : 0);
    }
    return parsed === nodeB.nthChild;
  }
  return true;
}

// checks that nodePath includes, in order, all nodes specified in parsedSelector
function selectorMatches(nodePath, parsedSelector) {
  var topDownNodePath = nodePath.slice(0).reverse();
  var matchIndex;
  var _iterator = _createForOfIteratorHelper(parsedSelector),
    _step;
  try {
    var _loop = function _loop() {
      var selectorNode = _step.value;
      if (selectorNode.directDesc) {
        if (nodesMatch.apply(void 0, [selectorNode].concat((0, _toConsumableArray2.default)(topDownNodePath.splice(0, 1))))) {
          return "continue";
        } else {
          return {
            v: false
          };
        }
      }
      matchIndex = (0, _findIndex.default)(topDownNodePath, function (pathNode) {
        return nodesMatch(selectorNode, pathNode);
      });
      if (matchIndex === -1) {
        return {
          v: false
        };
      }
      topDownNodePath.splice(0, matchIndex + 1);
    };
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _ret = _loop();
      if (_ret === "continue") continue;
      if ((0, _typeof2.default)(_ret) === "object") return _ret.v;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return true;
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/sendTelemetryData.js":
/*!************************************************************!*\
  !*** ./packages/@logrocket/utils/src/sendTelemetryData.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.sendTelemetry = sendTelemetry;
exports["default"] = sendErrorTelemetry;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));
var _logError = _interopRequireDefault(__webpack_require__(/*! ./logError */ "./packages/@logrocket/utils/src/logError.js"));
var _TraceKit = _interopRequireDefault(__webpack_require__(/*! ./TraceKit */ "./packages/@logrocket/utils/src/TraceKit.js"));
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
// eslint-disable-next-line no-undef
var SCRIPT_VERSION =  true ? "e61d691ee9b4d58762e823e42ca861a51c993e8f" : 0;
function _sendToSentry(data) {
  var XHR = window._lrXMLHttpRequest || XMLHttpRequest;
  try {
    var req = new XHR();
    var message = data.message;
    var url = 'https://e.logrocket.com/api/3/store/?sentry_version=7&sentry_client=http%2F3.8.0&sentry_key=b64162b4187a4c5caae8a68a7e291793';
    req.open('POST', url);
    req.send(JSON.stringify(_objectSpread({
      message: message,
      logger: 'javascript',
      platform: 'javascript',
      request: {
        headers: {
          'User-Agent': typeof navigator !== 'undefined' && navigator.userAgent
        },
        url: typeof location !== 'undefined' && location.href
      },
      release: SCRIPT_VERSION,
      environment:  false || 'test'
    }, data)));
  } catch (err) {
    (0, _logError.default)('Failed to send', err);
  }
}
function sendTelemetry(message, more) {
  if (typeof window !== 'undefined' && window._lrdebug) {
    return void (0, _logError.default)(message);
  }
  if (more && more.extra && more.extra.appID && typeof more.extra.appID.indexOf === 'function' && more.extra.appID.indexOf('au2drp/') === 0 && Math.random() >= 0.25) {
    return;
  }
  _sendToSentry(_objectSpread({
    message: message
  }, more));
}
function sendErrorTelemetry(err, payload) {
  try {
    var message = err.message;
    var stringPayload;
    try {
      stringPayload = JSON.stringify(payload).slice(0, 1000);
    } catch (err) {
      try {
        stringPayload = "Could not stringify payload: ".concat(Object.prototype.toString.call(payload));
      } catch (err) {/* nada */}
    }
    var stack;
    try {
      stack = _TraceKit.default.computeStackTrace(err).stack.map(function (frame) {
        return {
          filename: frame.url,
          lineno: frame.line,
          colno: frame.column,
          function: frame.func || '?'
        };
      });
    } catch (err) {
      /* nada */
    }
    _sendToSentry({
      message: message,
      extra: {
        stringPayload: stringPayload
      },
      exception: {
        values: [{
          type: err.type,
          value: message,
          stacktrace: {
            frames: stack
          }
        }]
      }
    });
  } catch (err) {
    (0, _logError.default)('Failed to send', err);
  }
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/setFromArray.js":
/*!*******************************************************!*\
  !*** ./packages/@logrocket/utils/src/setFromArray.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setFromArray;
function setFromArray(array) {
  var set = new Set();
  array.forEach(function (el) {
    return set.add(el);
  });
  return set;
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/setToArray.js":
/*!*****************************************************!*\
  !*** ./packages/@logrocket/utils/src/setToArray.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setToArray;
function setToArray(set) {
  var array = [];
  set.forEach(function (el) {
    return array.push(el);
  });
  return array;
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/shallowArsonify.js":
/*!**********************************************************!*\
  !*** ./packages/@logrocket/utils/src/shallowArsonify.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = shallowArsonify;
function shallowArsonify(value) {
  var type = {}.toString.call(value);
  switch (type) {
    case '[object Undefined]':
      {
        return {
          undefined: {}
        };
      }
    case '[object Null]':
      {
        return {
          null: {}
        };
      }
    case '[object Boolean]':
      {
        return {
          boolean: {
            bool: value
          }
        };
      }
    case '[object Number]':
      {
        return {
          number: {
            double: value
          }
        };
      }
    case '[object String]':
      {
        return {
          string: {
            string: value
          }
        };
      }
    case '[object Object]':
      {
        return {
          object: {
            map: value
          }
        };
      }
    case '[object Array]':
      {
        return {
          array: {
            map: value
          }
        };
      }
    case '[object Date]':
      {
        return {
          date: {
            double: value.getTime()
          }
        };
      }
    case '[object Error]':
      {
        return {
          string: {
            string: "".concat(value.name, ": ").concat(value.message)
          }
        };
      }
    default:
      {
        return {
          unsupported: {
            type: type
          }
        };
      }
  }
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/shallowDearsonify.js":
/*!************************************************************!*\
  !*** ./packages/@logrocket/utils/src/shallowDearsonify.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = shallowDearsonify;
/* eslint-disable consistent-return */

function shallowDearsonify(value) {
  var type = value.type || Object.keys(value)[0];
  switch (type) {
    case 'undefined':
      {
        return undefined;
      }
    case 'null':
      {
        return null;
      }
    case 'boolean':
      {
        return value.boolean.bool;
      }
    case 'number':
      {
        return value.number.double;
      }
    case 'string':
      {
        return value.string.string;
      }
    case 'object':
      {
        return value.object.map;
      }
    case 'array':
      {
        return Object.keys(value.array.map).reduce(function (array, key) {
          // eslint-disable-next-line no-param-reassign
          array[key] = value.array.map[key];
          return array;
        }, []);
      }
    case 'date':
      {
        return new Date(value.date.double);
      }
    case 'unsupported':
      {
        return value.unsupported.type;
      }
    default:
      {
        /* istanbul ignore next */
        throw new TypeError("Unexpected value in shallowDearsonify: ".concat(value));
      }
  }
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/startsWith.js":
/*!*****************************************************!*\
  !*** ./packages/@logrocket/utils/src/startsWith.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = startsWith;
function startsWith(value, search) {
  var pos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  return value && search && value.substring(pos, pos + search.length) === search;
}

/***/ }),

/***/ "./packages/@logrocket/utils/src/types.ts":
/*!************************************************!*\
  !*** ./packages/@logrocket/utils/src/types.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ "./packages/@logrocket/utils/src/userTraitStrings.ts":
/*!***********************************************************!*\
  !*** ./packages/@logrocket/utils/src/userTraitStrings.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.parseUserTraitString = exports.encodeUserTraitString = void 0;
// Character used to separate key/value pairs when concatenated, i.e. "key:value":
var USER_TRAIT_DELIMITER = ':';

// String used to temporarily escape above value when included in a user-defined string:
var delimiterReplace = String.fromCharCode(26);

/** Encode strings to be used as a custom key-value pair, ex. for user traits */
var encodeUserTraitString = function encodeUserTraitString() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return args
  // Escape instances of delimiter value in user-defined text:
  .map(function (str) {
    return str.replace(new RegExp(USER_TRAIT_DELIMITER, 'g'), delimiterReplace);
  }).join(USER_TRAIT_DELIMITER);
};

/** Split encoded user trait string into original key & value */
exports.encodeUserTraitString = encodeUserTraitString;
var parseUserTraitString = function parseUserTraitString(string) {
  var nonEmptyStr = string || USER_TRAIT_DELIMITER; // Ensure at least two strings will be returned
  return nonEmptyStr.split(USER_TRAIT_DELIMITER)
  // Restore previously escaped instances of delimiter character:
  .map(function (str) {
    return str.replace(new RegExp(delimiterReplace, 'g'), USER_TRAIT_DELIMITER);
  });
};
exports.parseUserTraitString = parseUserTraitString;

/***/ }),

/***/ "./packages/@logrocket/utils/src/uuid.js":
/*!***********************************************!*\
  !*** ./packages/@logrocket/utils/src/uuid.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = uuid;
// https://gist.github.com/jed/982883
// eslint-disable-next-line
function uuid(a) {
  return a ? (a ^ Math.random() * 16 >> a / 4).toString(16) : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, uuid);
}

/***/ }),

/***/ "./packages/logrocket/src/LogRocket.js":
/*!*********************************************!*\
  !*** ./packages/logrocket/src/LogRocket.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.MAX_QUEUE_SIZE = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));
var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));
var _objectWithoutProperties2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/objectWithoutProperties.js"));
var _network = _interopRequireDefault(__webpack_require__(/*! @logrocket/network */ "./packages/@logrocket/network/src/index.js"));
var _exceptions = __webpack_require__(/*! @logrocket/exceptions */ "./packages/@logrocket/exceptions/src/index.js");
var _console = _interopRequireDefault(__webpack_require__(/*! @logrocket/console */ "./packages/@logrocket/console/src/index.js"));
var _redux = __webpack_require__(/*! @logrocket/redux */ "./packages/@logrocket/redux/src/index.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var MAX_QUEUE_SIZE = 1000;
exports.MAX_QUEUE_SIZE = MAX_QUEUE_SIZE;
var considerIngestServerOption = function considerIngestServerOption() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    ingestServer = _ref.ingestServer,
    options = (0, _objectWithoutProperties2.default)(_ref, ["ingestServer"]);
  if (ingestServer) {
    return _objectSpread({
      serverURL: "".concat(ingestServer, "/i"),
      statsURL: "".concat(ingestServer, "/s")
    }, options);
  }
  return options;
};
var LogRocket = /*#__PURE__*/function () {
  function LogRocket() {
    var _this = this;
    (0, _classCallCheck2.default)(this, LogRocket);
    this._buffer = [];
    // TODO: tests for these exposed methods.
    ['log', 'info', 'warn', 'error', 'debug'].forEach(function (method) {
      _this[method] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this.addEvent('lr.core.LogEvent', function () {
          var consoleOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          if (method === 'error' && consoleOptions.shouldAggregateConsoleErrors) {
            _exceptions.Capture.captureMessage(_this, args[0], args, {}, true);
          }
          return {
            logLevel: method.toUpperCase(),
            args: args
          };
        }, {
          shouldCaptureStackTrace: true
        });
      };
    });
    this._isInitialized = false;
    this._installed = [];

    // expose a callback to get the session URL from the global context
    window._lr_surl_cb = this.getSessionURL.bind(this);
  }
  (0, _createClass2.default)(LogRocket, [{
    key: "addEvent",
    value: function addEvent(type, getMessage) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var time = Date.now();
      this._run(function (logger) {
        logger.addEvent(type, getMessage, _objectSpread(_objectSpread({}, opts), {}, {
          timeOverride: time
        }));
      });
    }
  }, {
    key: "onLogger",
    value: function onLogger(logger) {
      this._logger = logger;
      while (this._buffer.length > 0) {
        var f = this._buffer.shift();
        f(this._logger);
      }
    }
  }, {
    key: "_run",
    value: function _run(f) {
      if (this._isDisabled) {
        return;
      }
      if (this._logger) {
        f(this._logger);
      } else {
        if (this._buffer.length >= MAX_QUEUE_SIZE) {
          this._isDisabled = true;
          console.warn('LogRocket: script did not load. Check that you have a valid network connection.');
          this.uninstall();
          return;
        }
        this._buffer.push(f.bind(this));
      }
    }
  }, {
    key: "init",
    value: function init(appID) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!this._isInitialized) {
        var _opts$shouldAugmentNP = opts.shouldAugmentNPS,
          shouldAugmentNPS = _opts$shouldAugmentNP === void 0 ? true : _opts$shouldAugmentNP,
          _opts$shouldParseXHRB = opts.shouldParseXHRBlob,
          shouldParseXHRBlob = _opts$shouldParseXHRB === void 0 ? false : _opts$shouldParseXHRB,
          _opts$shouldDetectExc = opts.shouldDetectExceptions,
          shouldDetectExceptions = _opts$shouldDetectExc === void 0 ? true : _opts$shouldDetectExc;
        if (shouldDetectExceptions) {
          this._installed.push((0, _exceptions.registerExceptions)(this));
        }
        this._installed.push((0, _network.default)(this, {
          shouldAugmentNPS: !!shouldAugmentNPS,
          shouldParseXHRBlob: !!shouldParseXHRBlob
        }));
        this._installed.push((0, _console.default)(this));
        this._isInitialized = true;
        this._run(function (logger) {
          logger.init(appID, considerIngestServerOption(opts));
        });
      }
    }
  }, {
    key: "start",
    value: function start() {
      this._run(function (logger) {
        logger.start();
      });
    }
  }, {
    key: "uninstall",
    value: function uninstall() {
      this._installed.forEach(function (f) {
        return f();
      });
      this._buffer = [];
      this._run(function (logger) {
        logger.uninstall();
      });
    }
  }, {
    key: "identify",
    value: function identify(id, opts) {
      this._run(function (logger) {
        logger.identify(id, opts);
      });
    }
  }, {
    key: "startNewSession",
    value: function startNewSession() {
      this._run(function (logger) {
        logger.startNewSession();
      });
    }
  }, {
    key: "track",
    value: function track(customEventName, eventProperties) {
      this._run(function (logger) {
        logger.track(customEventName, eventProperties);
      });
    }
  }, {
    key: "getSessionURL",
    value: function getSessionURL(cb) {
      if (typeof cb !== 'function') {
        throw new Error('LogRocket: must pass callback to getSessionURL()');
      }
      this._run(function (logger) {
        if (logger.getSessionURL) {
          logger.getSessionURL(cb);
        } else {
          cb(logger.recordingURL);
        }
      });
    }
  }, {
    key: "trackScrollEvent",
    value: function trackScrollEvent(target) {
      // Only reigster the event if the core logger is available,
      //  otherwise we won't yet have captured the target element:
      if (this._logger) {
        this._logger.trackScrollEvent(target);
      }
    }
  }, {
    key: "getVersion",
    value: function getVersion(cb) {
      this._run(function (logger) {
        cb(logger.version);
      });
    }
  }, {
    key: "captureMessage",
    value: function captureMessage(message) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      _exceptions.Capture.captureMessage(this, message, [message], options);
    }
  }, {
    key: "captureException",
    value: function captureException(exception) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      _exceptions.Capture.captureException(this, exception, options);
    }
  }, {
    key: "version",
    get: function get() {
      return this._logger && this._logger.version;
    }
  }, {
    key: "sessionURL",
    get: function get() {
      return this._logger && this._logger.recordingURL;
    }
  }, {
    key: "recordingURL",
    get: function get() {
      return this._logger && this._logger.recordingURL;
    }
  }, {
    key: "recordingID",
    get: function get() {
      return this._logger && this._logger.recordingID;
    }
  }, {
    key: "threadID",
    get: function get() {
      return this._logger && this._logger.threadID;
    }
  }, {
    key: "tabID",
    get: function get() {
      return this._logger && this._logger.tabID;
    }
  }, {
    key: "reduxEnhancer",
    value: function reduxEnhancer() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return (0, _redux.createEnhancer)(this, options);
    }
  }, {
    key: "reduxMiddleware",
    value: function reduxMiddleware() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return (0, _redux.createMiddleware)(this, options);
    }
  }, {
    key: "isDisabled",
    get: function get() {
      return !!(this._isDisabled || this._logger && this._logger._isDisabled);
    }
  }]);
  return LogRocket;
}();
exports["default"] = LogRocket;

/***/ }),

/***/ "./packages/logrocket/src/makeLogRocket.js":
/*!*************************************************!*\
  !*** ./packages/logrocket/src/makeLogRocket.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = makeLogRocket;
var _LogRocket = _interopRequireDefault(__webpack_require__(/*! ./LogRocket */ "./packages/logrocket/src/LogRocket.js"));
var REACT_NATIVE_NOTICE = 'LogRocket does not yet support React Native.';
var makeNoopPolyfill = function makeNoopPolyfill() {
  return {
    init: function init() {},
    uninstall: function uninstall() {},
    log: function log() {},
    info: function info() {},
    warn: function warn() {},
    error: function error() {},
    debug: function debug() {},
    addEvent: function addEvent() {},
    identify: function identify() {},
    start: function start() {},
    get threadID() {
      return null;
    },
    get recordingID() {
      return null;
    },
    get recordingURL() {
      return null;
    },
    reduxEnhancer: function reduxEnhancer() {
      return function (store) {
        return function () {
          return store.apply(void 0, arguments);
        };
      };
    },
    reduxMiddleware: function reduxMiddleware() {
      return function () {
        return function (next) {
          return function (action) {
            return next(action);
          };
        };
      };
    },
    track: function track() {},
    getSessionURL: function getSessionURL() {},
    getVersion: function getVersion() {},
    startNewSession: function startNewSession() {},
    onLogger: function onLogger() {},
    setClock: function setClock() {},
    captureMessage: function captureMessage() {},
    captureException: function captureException() {}
  };
};
function makeLogRocket() {
  var getLogger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    throw new Error(REACT_NATIVE_NOTICE);
  }
  if (typeof window !== 'undefined') {
    if (window._disableLogRocket) {
      return makeNoopPolyfill();
    }
    if (window.MutationObserver && window.WeakMap) {
      // Save window globals that we rely on.
      window._lrMutationObserver = window.MutationObserver;
      var instance = new _LogRocket.default();
      getLogger(instance);
      return instance;
    }
  }
  return makeNoopPolyfill();
}

/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_DataView.js":
/*!********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_DataView.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./packages/@logrocket/utils/node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./packages/@logrocket/utils/node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_Hash.js":
/*!****************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_Hash.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var hashClear = __webpack_require__(/*! ./_hashClear */ "./packages/@logrocket/utils/node_modules/lodash/_hashClear.js"),
    hashDelete = __webpack_require__(/*! ./_hashDelete */ "./packages/@logrocket/utils/node_modules/lodash/_hashDelete.js"),
    hashGet = __webpack_require__(/*! ./_hashGet */ "./packages/@logrocket/utils/node_modules/lodash/_hashGet.js"),
    hashHas = __webpack_require__(/*! ./_hashHas */ "./packages/@logrocket/utils/node_modules/lodash/_hashHas.js"),
    hashSet = __webpack_require__(/*! ./_hashSet */ "./packages/@logrocket/utils/node_modules/lodash/_hashSet.js");

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_ListCache.js":
/*!*********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_ListCache.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var listCacheClear = __webpack_require__(/*! ./_listCacheClear */ "./packages/@logrocket/utils/node_modules/lodash/_listCacheClear.js"),
    listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ "./packages/@logrocket/utils/node_modules/lodash/_listCacheDelete.js"),
    listCacheGet = __webpack_require__(/*! ./_listCacheGet */ "./packages/@logrocket/utils/node_modules/lodash/_listCacheGet.js"),
    listCacheHas = __webpack_require__(/*! ./_listCacheHas */ "./packages/@logrocket/utils/node_modules/lodash/_listCacheHas.js"),
    listCacheSet = __webpack_require__(/*! ./_listCacheSet */ "./packages/@logrocket/utils/node_modules/lodash/_listCacheSet.js");

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_Map.js":
/*!***************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_Map.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./packages/@logrocket/utils/node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./packages/@logrocket/utils/node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_MapCache.js":
/*!********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_MapCache.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ "./packages/@logrocket/utils/node_modules/lodash/_mapCacheClear.js"),
    mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ "./packages/@logrocket/utils/node_modules/lodash/_mapCacheDelete.js"),
    mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ "./packages/@logrocket/utils/node_modules/lodash/_mapCacheGet.js"),
    mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ "./packages/@logrocket/utils/node_modules/lodash/_mapCacheHas.js"),
    mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ "./packages/@logrocket/utils/node_modules/lodash/_mapCacheSet.js");

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_Promise.js":
/*!*******************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_Promise.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./packages/@logrocket/utils/node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./packages/@logrocket/utils/node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_Set.js":
/*!***************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_Set.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./packages/@logrocket/utils/node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./packages/@logrocket/utils/node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_SetCache.js":
/*!********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_SetCache.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var MapCache = __webpack_require__(/*! ./_MapCache */ "./packages/@logrocket/utils/node_modules/lodash/_MapCache.js"),
    setCacheAdd = __webpack_require__(/*! ./_setCacheAdd */ "./packages/@logrocket/utils/node_modules/lodash/_setCacheAdd.js"),
    setCacheHas = __webpack_require__(/*! ./_setCacheHas */ "./packages/@logrocket/utils/node_modules/lodash/_setCacheHas.js");

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_Stack.js":
/*!*****************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_Stack.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./packages/@logrocket/utils/node_modules/lodash/_ListCache.js"),
    stackClear = __webpack_require__(/*! ./_stackClear */ "./packages/@logrocket/utils/node_modules/lodash/_stackClear.js"),
    stackDelete = __webpack_require__(/*! ./_stackDelete */ "./packages/@logrocket/utils/node_modules/lodash/_stackDelete.js"),
    stackGet = __webpack_require__(/*! ./_stackGet */ "./packages/@logrocket/utils/node_modules/lodash/_stackGet.js"),
    stackHas = __webpack_require__(/*! ./_stackHas */ "./packages/@logrocket/utils/node_modules/lodash/_stackHas.js"),
    stackSet = __webpack_require__(/*! ./_stackSet */ "./packages/@logrocket/utils/node_modules/lodash/_stackSet.js");

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_Symbol.js":
/*!******************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_Symbol.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./packages/@logrocket/utils/node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_Uint8Array.js":
/*!**********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_Uint8Array.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./packages/@logrocket/utils/node_modules/lodash/_root.js");

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_WeakMap.js":
/*!*******************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_WeakMap.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./packages/@logrocket/utils/node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./packages/@logrocket/utils/node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_arrayFilter.js":
/*!***********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_arrayFilter.js ***!
  \***********************************************************************/
/***/ (function(module) {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_arrayLikeKeys.js":
/*!*************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_arrayLikeKeys.js ***!
  \*************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseTimes = __webpack_require__(/*! ./_baseTimes */ "./packages/@logrocket/utils/node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./packages/@logrocket/utils/node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./packages/@logrocket/utils/node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./packages/@logrocket/utils/node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./packages/@logrocket/utils/node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./packages/@logrocket/utils/node_modules/lodash/isTypedArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_arrayMap.js":
/*!********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_arrayMap.js ***!
  \********************************************************************/
/***/ (function(module) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_arrayPush.js":
/*!*********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_arrayPush.js ***!
  \*********************************************************************/
/***/ (function(module) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_arraySome.js":
/*!*********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_arraySome.js ***!
  \*********************************************************************/
/***/ (function(module) {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_assocIndexOf.js":
/*!************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_assocIndexOf.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var eq = __webpack_require__(/*! ./eq */ "./packages/@logrocket/utils/node_modules/lodash/eq.js");

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_baseGet.js":
/*!*******************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseGet.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var castPath = __webpack_require__(/*! ./_castPath */ "./packages/@logrocket/utils/node_modules/lodash/_castPath.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./packages/@logrocket/utils/node_modules/lodash/_toKey.js");

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_baseGetAllKeys.js":
/*!**************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseGetAllKeys.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./packages/@logrocket/utils/node_modules/lodash/_arrayPush.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./packages/@logrocket/utils/node_modules/lodash/isArray.js");

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_baseGetTag.js":
/*!**********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseGetTag.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./packages/@logrocket/utils/node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./packages/@logrocket/utils/node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./packages/@logrocket/utils/node_modules/lodash/_objectToString.js");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_baseHasIn.js":
/*!*********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseHasIn.js ***!
  \*********************************************************************/
/***/ (function(module) {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_baseIsArguments.js":
/*!***************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseIsArguments.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./packages/@logrocket/utils/node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./packages/@logrocket/utils/node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_baseIsEqual.js":
/*!***********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseIsEqual.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseIsEqualDeep = __webpack_require__(/*! ./_baseIsEqualDeep */ "./packages/@logrocket/utils/node_modules/lodash/_baseIsEqualDeep.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./packages/@logrocket/utils/node_modules/lodash/isObjectLike.js");

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_baseIsEqualDeep.js":
/*!***************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseIsEqualDeep.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Stack = __webpack_require__(/*! ./_Stack */ "./packages/@logrocket/utils/node_modules/lodash/_Stack.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./packages/@logrocket/utils/node_modules/lodash/_equalArrays.js"),
    equalByTag = __webpack_require__(/*! ./_equalByTag */ "./packages/@logrocket/utils/node_modules/lodash/_equalByTag.js"),
    equalObjects = __webpack_require__(/*! ./_equalObjects */ "./packages/@logrocket/utils/node_modules/lodash/_equalObjects.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./packages/@logrocket/utils/node_modules/lodash/_getTag.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./packages/@logrocket/utils/node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./packages/@logrocket/utils/node_modules/lodash/isBuffer.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./packages/@logrocket/utils/node_modules/lodash/isTypedArray.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_baseIsMatch.js":
/*!***********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseIsMatch.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Stack = __webpack_require__(/*! ./_Stack */ "./packages/@logrocket/utils/node_modules/lodash/_Stack.js"),
    baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./packages/@logrocket/utils/node_modules/lodash/_baseIsEqual.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_baseIsNative.js":
/*!************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseIsNative.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "./packages/@logrocket/utils/node_modules/lodash/isFunction.js"),
    isMasked = __webpack_require__(/*! ./_isMasked */ "./packages/@logrocket/utils/node_modules/lodash/_isMasked.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./packages/@logrocket/utils/node_modules/lodash/isObject.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./packages/@logrocket/utils/node_modules/lodash/_toSource.js");

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_baseIsTypedArray.js":
/*!****************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseIsTypedArray.js ***!
  \****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./packages/@logrocket/utils/node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./packages/@logrocket/utils/node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./packages/@logrocket/utils/node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_baseIteratee.js":
/*!************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseIteratee.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseMatches = __webpack_require__(/*! ./_baseMatches */ "./packages/@logrocket/utils/node_modules/lodash/_baseMatches.js"),
    baseMatchesProperty = __webpack_require__(/*! ./_baseMatchesProperty */ "./packages/@logrocket/utils/node_modules/lodash/_baseMatchesProperty.js"),
    identity = __webpack_require__(/*! ./identity */ "./packages/@logrocket/utils/node_modules/lodash/identity.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./packages/@logrocket/utils/node_modules/lodash/isArray.js"),
    property = __webpack_require__(/*! ./property */ "./packages/@logrocket/utils/node_modules/lodash/property.js");

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_baseKeys.js":
/*!********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseKeys.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isPrototype = __webpack_require__(/*! ./_isPrototype */ "./packages/@logrocket/utils/node_modules/lodash/_isPrototype.js"),
    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ "./packages/@logrocket/utils/node_modules/lodash/_nativeKeys.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_baseMatches.js":
/*!***********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseMatches.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseIsMatch = __webpack_require__(/*! ./_baseIsMatch */ "./packages/@logrocket/utils/node_modules/lodash/_baseIsMatch.js"),
    getMatchData = __webpack_require__(/*! ./_getMatchData */ "./packages/@logrocket/utils/node_modules/lodash/_getMatchData.js"),
    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./packages/@logrocket/utils/node_modules/lodash/_matchesStrictComparable.js");

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_baseMatchesProperty.js":
/*!*******************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseMatchesProperty.js ***!
  \*******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./packages/@logrocket/utils/node_modules/lodash/_baseIsEqual.js"),
    get = __webpack_require__(/*! ./get */ "./packages/@logrocket/utils/node_modules/lodash/get.js"),
    hasIn = __webpack_require__(/*! ./hasIn */ "./packages/@logrocket/utils/node_modules/lodash/hasIn.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./packages/@logrocket/utils/node_modules/lodash/_isKey.js"),
    isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./packages/@logrocket/utils/node_modules/lodash/_isStrictComparable.js"),
    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./packages/@logrocket/utils/node_modules/lodash/_matchesStrictComparable.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./packages/@logrocket/utils/node_modules/lodash/_toKey.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_baseProperty.js":
/*!************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseProperty.js ***!
  \************************************************************************/
/***/ (function(module) {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_basePropertyDeep.js":
/*!****************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_basePropertyDeep.js ***!
  \****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./packages/@logrocket/utils/node_modules/lodash/_baseGet.js");

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_baseSortedIndexBy.js":
/*!*****************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseSortedIndexBy.js ***!
  \*****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isSymbol = __webpack_require__(/*! ./isSymbol */ "./packages/@logrocket/utils/node_modules/lodash/isSymbol.js");

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH = 4294967295,
    MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor,
    nativeMin = Math.min;

/**
 * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
 * which invokes `iteratee` for `value` and each element of `array` to compute
 * their sort ranking. The iteratee is invoked with one argument; (value).
 *
 * @private
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Function} iteratee The iteratee invoked per element.
 * @param {boolean} [retHighest] Specify returning the highest qualified index.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 */
function baseSortedIndexBy(array, value, iteratee, retHighest) {
  var low = 0,
      high = array == null ? 0 : array.length;
  if (high === 0) {
    return 0;
  }

  value = iteratee(value);
  var valIsNaN = value !== value,
      valIsNull = value === null,
      valIsSymbol = isSymbol(value),
      valIsUndefined = value === undefined;

  while (low < high) {
    var mid = nativeFloor((low + high) / 2),
        computed = iteratee(array[mid]),
        othIsDefined = computed !== undefined,
        othIsNull = computed === null,
        othIsReflexive = computed === computed,
        othIsSymbol = isSymbol(computed);

    if (valIsNaN) {
      var setLow = retHighest || othIsReflexive;
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined);
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
    } else if (othIsNull || othIsSymbol) {
      setLow = false;
    } else {
      setLow = retHighest ? (computed <= value) : (computed < value);
    }
    if (setLow) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return nativeMin(high, MAX_ARRAY_INDEX);
}

module.exports = baseSortedIndexBy;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_baseTimes.js":
/*!*********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseTimes.js ***!
  \*********************************************************************/
/***/ (function(module) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_baseToString.js":
/*!************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseToString.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./packages/@logrocket/utils/node_modules/lodash/_Symbol.js"),
    arrayMap = __webpack_require__(/*! ./_arrayMap */ "./packages/@logrocket/utils/node_modules/lodash/_arrayMap.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./packages/@logrocket/utils/node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./packages/@logrocket/utils/node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_baseUnary.js":
/*!*********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_baseUnary.js ***!
  \*********************************************************************/
/***/ (function(module) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_cacheHas.js":
/*!********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_cacheHas.js ***!
  \********************************************************************/
/***/ (function(module) {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_castPath.js":
/*!********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_castPath.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isArray = __webpack_require__(/*! ./isArray */ "./packages/@logrocket/utils/node_modules/lodash/isArray.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./packages/@logrocket/utils/node_modules/lodash/_isKey.js"),
    stringToPath = __webpack_require__(/*! ./_stringToPath */ "./packages/@logrocket/utils/node_modules/lodash/_stringToPath.js"),
    toString = __webpack_require__(/*! ./toString */ "./packages/@logrocket/utils/node_modules/lodash/toString.js");

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_coreJsData.js":
/*!**********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_coreJsData.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./packages/@logrocket/utils/node_modules/lodash/_root.js");

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_equalArrays.js":
/*!***********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_equalArrays.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var SetCache = __webpack_require__(/*! ./_SetCache */ "./packages/@logrocket/utils/node_modules/lodash/_SetCache.js"),
    arraySome = __webpack_require__(/*! ./_arraySome */ "./packages/@logrocket/utils/node_modules/lodash/_arraySome.js"),
    cacheHas = __webpack_require__(/*! ./_cacheHas */ "./packages/@logrocket/utils/node_modules/lodash/_cacheHas.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_equalByTag.js":
/*!**********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_equalByTag.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./packages/@logrocket/utils/node_modules/lodash/_Symbol.js"),
    Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./packages/@logrocket/utils/node_modules/lodash/_Uint8Array.js"),
    eq = __webpack_require__(/*! ./eq */ "./packages/@logrocket/utils/node_modules/lodash/eq.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./packages/@logrocket/utils/node_modules/lodash/_equalArrays.js"),
    mapToArray = __webpack_require__(/*! ./_mapToArray */ "./packages/@logrocket/utils/node_modules/lodash/_mapToArray.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./packages/@logrocket/utils/node_modules/lodash/_setToArray.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_equalObjects.js":
/*!************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_equalObjects.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./packages/@logrocket/utils/node_modules/lodash/_getAllKeys.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_freeGlobal.js":
/*!**********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_freeGlobal.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

module.exports = freeGlobal;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_getAllKeys.js":
/*!**********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_getAllKeys.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./packages/@logrocket/utils/node_modules/lodash/_baseGetAllKeys.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./packages/@logrocket/utils/node_modules/lodash/_getSymbols.js"),
    keys = __webpack_require__(/*! ./keys */ "./packages/@logrocket/utils/node_modules/lodash/keys.js");

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_getMapData.js":
/*!**********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_getMapData.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isKeyable = __webpack_require__(/*! ./_isKeyable */ "./packages/@logrocket/utils/node_modules/lodash/_isKeyable.js");

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_getMatchData.js":
/*!************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_getMatchData.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./packages/@logrocket/utils/node_modules/lodash/_isStrictComparable.js"),
    keys = __webpack_require__(/*! ./keys */ "./packages/@logrocket/utils/node_modules/lodash/keys.js");

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_getNative.js":
/*!*********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_getNative.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ "./packages/@logrocket/utils/node_modules/lodash/_baseIsNative.js"),
    getValue = __webpack_require__(/*! ./_getValue */ "./packages/@logrocket/utils/node_modules/lodash/_getValue.js");

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_getRawTag.js":
/*!*********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_getRawTag.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./packages/@logrocket/utils/node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_getSymbols.js":
/*!**********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_getSymbols.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "./packages/@logrocket/utils/node_modules/lodash/_arrayFilter.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./packages/@logrocket/utils/node_modules/lodash/stubArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_getTag.js":
/*!******************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_getTag.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DataView = __webpack_require__(/*! ./_DataView */ "./packages/@logrocket/utils/node_modules/lodash/_DataView.js"),
    Map = __webpack_require__(/*! ./_Map */ "./packages/@logrocket/utils/node_modules/lodash/_Map.js"),
    Promise = __webpack_require__(/*! ./_Promise */ "./packages/@logrocket/utils/node_modules/lodash/_Promise.js"),
    Set = __webpack_require__(/*! ./_Set */ "./packages/@logrocket/utils/node_modules/lodash/_Set.js"),
    WeakMap = __webpack_require__(/*! ./_WeakMap */ "./packages/@logrocket/utils/node_modules/lodash/_WeakMap.js"),
    baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./packages/@logrocket/utils/node_modules/lodash/_baseGetTag.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./packages/@logrocket/utils/node_modules/lodash/_toSource.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_getValue.js":
/*!********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_getValue.js ***!
  \********************************************************************/
/***/ (function(module) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_hasPath.js":
/*!*******************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_hasPath.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var castPath = __webpack_require__(/*! ./_castPath */ "./packages/@logrocket/utils/node_modules/lodash/_castPath.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./packages/@logrocket/utils/node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./packages/@logrocket/utils/node_modules/lodash/isArray.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./packages/@logrocket/utils/node_modules/lodash/_isIndex.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./packages/@logrocket/utils/node_modules/lodash/isLength.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./packages/@logrocket/utils/node_modules/lodash/_toKey.js");

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_hashClear.js":
/*!*********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_hashClear.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./packages/@logrocket/utils/node_modules/lodash/_nativeCreate.js");

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_hashDelete.js":
/*!**********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_hashDelete.js ***!
  \**********************************************************************/
/***/ (function(module) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_hashGet.js":
/*!*******************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_hashGet.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./packages/@logrocket/utils/node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_hashHas.js":
/*!*******************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_hashHas.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./packages/@logrocket/utils/node_modules/lodash/_nativeCreate.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_hashSet.js":
/*!*******************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_hashSet.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./packages/@logrocket/utils/node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_isIndex.js":
/*!*******************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_isIndex.js ***!
  \*******************************************************************/
/***/ (function(module) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_isKey.js":
/*!*****************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_isKey.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isArray = __webpack_require__(/*! ./isArray */ "./packages/@logrocket/utils/node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./packages/@logrocket/utils/node_modules/lodash/isSymbol.js");

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_isKeyable.js":
/*!*********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_isKeyable.js ***!
  \*********************************************************************/
/***/ (function(module) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_isMasked.js":
/*!********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_isMasked.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var coreJsData = __webpack_require__(/*! ./_coreJsData */ "./packages/@logrocket/utils/node_modules/lodash/_coreJsData.js");

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_isPrototype.js":
/*!***********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_isPrototype.js ***!
  \***********************************************************************/
/***/ (function(module) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_isStrictComparable.js":
/*!******************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_isStrictComparable.js ***!
  \******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./packages/@logrocket/utils/node_modules/lodash/isObject.js");

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_listCacheClear.js":
/*!**************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_listCacheClear.js ***!
  \**************************************************************************/
/***/ (function(module) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_listCacheDelete.js":
/*!***************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_listCacheDelete.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./packages/@logrocket/utils/node_modules/lodash/_assocIndexOf.js");

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_listCacheGet.js":
/*!************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_listCacheGet.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./packages/@logrocket/utils/node_modules/lodash/_assocIndexOf.js");

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_listCacheHas.js":
/*!************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_listCacheHas.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./packages/@logrocket/utils/node_modules/lodash/_assocIndexOf.js");

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_listCacheSet.js":
/*!************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_listCacheSet.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./packages/@logrocket/utils/node_modules/lodash/_assocIndexOf.js");

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_mapCacheClear.js":
/*!*************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_mapCacheClear.js ***!
  \*************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Hash = __webpack_require__(/*! ./_Hash */ "./packages/@logrocket/utils/node_modules/lodash/_Hash.js"),
    ListCache = __webpack_require__(/*! ./_ListCache */ "./packages/@logrocket/utils/node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./packages/@logrocket/utils/node_modules/lodash/_Map.js");

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_mapCacheDelete.js":
/*!**************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_mapCacheDelete.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./packages/@logrocket/utils/node_modules/lodash/_getMapData.js");

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_mapCacheGet.js":
/*!***********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_mapCacheGet.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./packages/@logrocket/utils/node_modules/lodash/_getMapData.js");

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_mapCacheHas.js":
/*!***********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_mapCacheHas.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./packages/@logrocket/utils/node_modules/lodash/_getMapData.js");

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_mapCacheSet.js":
/*!***********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_mapCacheSet.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./packages/@logrocket/utils/node_modules/lodash/_getMapData.js");

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_mapToArray.js":
/*!**********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_mapToArray.js ***!
  \**********************************************************************/
/***/ (function(module) {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_matchesStrictComparable.js":
/*!***********************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_matchesStrictComparable.js ***!
  \***********************************************************************************/
/***/ (function(module) {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_memoizeCapped.js":
/*!*************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_memoizeCapped.js ***!
  \*************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var memoize = __webpack_require__(/*! ./memoize */ "./packages/@logrocket/utils/node_modules/lodash/memoize.js");

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_nativeCreate.js":
/*!************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_nativeCreate.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./packages/@logrocket/utils/node_modules/lodash/_getNative.js");

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_nativeKeys.js":
/*!**********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_nativeKeys.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var overArg = __webpack_require__(/*! ./_overArg */ "./packages/@logrocket/utils/node_modules/lodash/_overArg.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_nodeUtil.js":
/*!********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_nodeUtil.js ***!
  \********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./packages/@logrocket/utils/node_modules/lodash/_freeGlobal.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_objectToString.js":
/*!**************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_objectToString.js ***!
  \**************************************************************************/
/***/ (function(module) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_overArg.js":
/*!*******************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_overArg.js ***!
  \*******************************************************************/
/***/ (function(module) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_root.js":
/*!****************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_root.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./packages/@logrocket/utils/node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_setCacheAdd.js":
/*!***********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_setCacheAdd.js ***!
  \***********************************************************************/
/***/ (function(module) {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_setCacheHas.js":
/*!***********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_setCacheHas.js ***!
  \***********************************************************************/
/***/ (function(module) {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_setToArray.js":
/*!**********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_setToArray.js ***!
  \**********************************************************************/
/***/ (function(module) {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_stackClear.js":
/*!**********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_stackClear.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./packages/@logrocket/utils/node_modules/lodash/_ListCache.js");

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_stackDelete.js":
/*!***********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_stackDelete.js ***!
  \***********************************************************************/
/***/ (function(module) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_stackGet.js":
/*!********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_stackGet.js ***!
  \********************************************************************/
/***/ (function(module) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_stackHas.js":
/*!********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_stackHas.js ***!
  \********************************************************************/
/***/ (function(module) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_stackSet.js":
/*!********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_stackSet.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./packages/@logrocket/utils/node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./packages/@logrocket/utils/node_modules/lodash/_Map.js"),
    MapCache = __webpack_require__(/*! ./_MapCache */ "./packages/@logrocket/utils/node_modules/lodash/_MapCache.js");

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_stringToPath.js":
/*!************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_stringToPath.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(/*! ./_memoizeCapped */ "./packages/@logrocket/utils/node_modules/lodash/_memoizeCapped.js");

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_toKey.js":
/*!*****************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_toKey.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isSymbol = __webpack_require__(/*! ./isSymbol */ "./packages/@logrocket/utils/node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/_toSource.js":
/*!********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/_toSource.js ***!
  \********************************************************************/
/***/ (function(module) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/eq.js":
/*!*************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/eq.js ***!
  \*************************************************************/
/***/ (function(module) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/get.js":
/*!**************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/get.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./packages/@logrocket/utils/node_modules/lodash/_baseGet.js");

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/hasIn.js":
/*!****************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/hasIn.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseHasIn = __webpack_require__(/*! ./_baseHasIn */ "./packages/@logrocket/utils/node_modules/lodash/_baseHasIn.js"),
    hasPath = __webpack_require__(/*! ./_hasPath */ "./packages/@logrocket/utils/node_modules/lodash/_hasPath.js");

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/identity.js":
/*!*******************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/identity.js ***!
  \*******************************************************************/
/***/ (function(module) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/isArguments.js":
/*!**********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/isArguments.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "./packages/@logrocket/utils/node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./packages/@logrocket/utils/node_modules/lodash/isObjectLike.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/isArray.js":
/*!******************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/isArray.js ***!
  \******************************************************************/
/***/ (function(module) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/isArrayLike.js":
/*!**********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/isArrayLike.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "./packages/@logrocket/utils/node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./packages/@logrocket/utils/node_modules/lodash/isLength.js");

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/isBuffer.js":
/*!*******************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/isBuffer.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(/*! ./_root */ "./packages/@logrocket/utils/node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__(/*! ./stubFalse */ "./packages/@logrocket/utils/node_modules/lodash/stubFalse.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/isFunction.js":
/*!*********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/isFunction.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./packages/@logrocket/utils/node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./packages/@logrocket/utils/node_modules/lodash/isObject.js");

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/isLength.js":
/*!*******************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/isLength.js ***!
  \*******************************************************************/
/***/ (function(module) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/isObject.js":
/*!*******************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/isObject.js ***!
  \*******************************************************************/
/***/ (function(module) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/isObjectLike.js":
/*!***********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/isObjectLike.js ***!
  \***********************************************************************/
/***/ (function(module) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/isSymbol.js":
/*!*******************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/isSymbol.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./packages/@logrocket/utils/node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./packages/@logrocket/utils/node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/isTypedArray.js":
/*!***********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/isTypedArray.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "./packages/@logrocket/utils/node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./packages/@logrocket/utils/node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./packages/@logrocket/utils/node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/keys.js":
/*!***************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/keys.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./packages/@logrocket/utils/node_modules/lodash/_arrayLikeKeys.js"),
    baseKeys = __webpack_require__(/*! ./_baseKeys */ "./packages/@logrocket/utils/node_modules/lodash/_baseKeys.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./packages/@logrocket/utils/node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/memoize.js":
/*!******************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/memoize.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var MapCache = __webpack_require__(/*! ./_MapCache */ "./packages/@logrocket/utils/node_modules/lodash/_MapCache.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/property.js":
/*!*******************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/property.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseProperty = __webpack_require__(/*! ./_baseProperty */ "./packages/@logrocket/utils/node_modules/lodash/_baseProperty.js"),
    basePropertyDeep = __webpack_require__(/*! ./_basePropertyDeep */ "./packages/@logrocket/utils/node_modules/lodash/_basePropertyDeep.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./packages/@logrocket/utils/node_modules/lodash/_isKey.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./packages/@logrocket/utils/node_modules/lodash/_toKey.js");

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/sortedLastIndexBy.js":
/*!****************************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/sortedLastIndexBy.js ***!
  \****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./packages/@logrocket/utils/node_modules/lodash/_baseIteratee.js"),
    baseSortedIndexBy = __webpack_require__(/*! ./_baseSortedIndexBy */ "./packages/@logrocket/utils/node_modules/lodash/_baseSortedIndexBy.js");

/**
 * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
 * which is invoked for `value` and each element of `array` to compute their
 * sort ranking. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * var objects = [{ 'x': 4 }, { 'x': 5 }];
 *
 * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
 * // => 1
 *
 * // The `_.property` iteratee shorthand.
 * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
 * // => 1
 */
function sortedLastIndexBy(array, value, iteratee) {
  return baseSortedIndexBy(array, value, baseIteratee(iteratee, 2), true);
}

module.exports = sortedLastIndexBy;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/stubArray.js":
/*!********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/stubArray.js ***!
  \********************************************************************/
/***/ (function(module) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/stubFalse.js":
/*!********************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/stubFalse.js ***!
  \********************************************************************/
/***/ (function(module) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "./packages/@logrocket/utils/node_modules/lodash/toString.js":
/*!*******************************************************************!*\
  !*** ./packages/@logrocket/utils/node_modules/lodash/toString.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseToString = __webpack_require__(/*! ./_baseToString */ "./packages/@logrocket/utils/node_modules/lodash/_baseToString.js");

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/***/ (function(module) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/***/ (function(module) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}
module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/***/ (function(module) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toPropertyKey = __webpack_require__(/*! ./toPropertyKey.js */ "./node_modules/@babel/runtime/helpers/toPropertyKey.js");
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toPropertyKey = __webpack_require__(/*! ./toPropertyKey.js */ "./node_modules/@babel/runtime/helpers/toPropertyKey.js");
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/***/ (function(module) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \****************************************************************/
/***/ (function(module) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/***/ (function(module) {

function _iterableToArrayLimit(arr, i) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s,
      _e,
      _x,
      _r,
      _arr = [],
      _n = !0,
      _d = !1;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i) return;
        _n = !1;
      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return;
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/***/ (function(module) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \******************************************************************/
/***/ (function(module) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/objectWithoutProperties.js":
/*!************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/objectWithoutProperties.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var objectWithoutPropertiesLoose = __webpack_require__(/*! ./objectWithoutPropertiesLoose.js */ "./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js");
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
module.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js ***!
  \*****************************************************************************/
/***/ (function(module) {

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
module.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles.js */ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js");
var iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit.js */ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");
var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");
var nonIterableRest = __webpack_require__(/*! ./nonIterableRest.js */ "./node_modules/@babel/runtime/helpers/nonIterableRest.js");
function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}
module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toConsumableArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles.js */ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js");
var iterableToArray = __webpack_require__(/*! ./iterableToArray.js */ "./node_modules/@babel/runtime/helpers/iterableToArray.js");
var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");
var nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread.js */ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js");
function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}
module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toPrimitive.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toPrimitive.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _typeof = (__webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/typeof.js")["default"]);
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
module.exports = _toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toPropertyKey.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toPropertyKey.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _typeof = (__webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/typeof.js")["default"]);
var toPrimitive = __webpack_require__(/*! ./toPrimitive.js */ "./node_modules/@babel/runtime/helpers/toPrimitive.js");
function _toPropertyKey(arg) {
  var key = toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/***/ (function(module) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}
module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	!function() {
/******/ 		__webpack_require__.nmd = function(module) {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
var exports = __webpack_exports__;
/*!*****************************************!*\
  !*** ./packages/logrocket/src/setup.js ***!
  \*****************************************/


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setup;
var _objectWithoutProperties2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/objectWithoutProperties.js"));
var _makeLogRocket = _interopRequireDefault(__webpack_require__(/*! ./makeLogRocket */ "./packages/logrocket/src/makeLogRocket.js"));
var CDN_SERVER_MAP = {
  'cdn.logrocket.io': 'https://r.logrocket.io',
  'cdn.lr-ingest.io': 'https://r.lr-ingest.io',
  'cdn.lr-in.com': 'https://r.lr-in.com',
  'cdn.lr-in-prod.com': 'https://r.lr-in-prod.com',
  'cdn.lr-ingest.com': 'https://r.lr-ingest.com',
  'cdn.ingest-lr.com': 'https://r.ingest-lr.com',
  'cdn.lr-intake.com': 'https://r.lr-intake.com',
  'cdn.intake-lr.com': 'https://r.intake-lr.com',
  'cdn.logr-ingest.com': 'https://r.logr-ingest.com',
  'cdn-staging.logrocket.io': 'https://staging-i.logrocket.io',
  'cdn-staging.lr-ingest.io': 'https://staging-i.lr-ingest.io',
  'cdn-staging.lr-in.com': 'https://staging-i.lr-in.com',
  'cdn-staging.lr-in-prod.com': 'https://staging-i.lr-in-prod.com',
  'cdn-staging.lr-ingest.com': 'https://staging-i.lr-ingest.com',
  'cdn-staging.ingest-lr.com': 'https://staging-i.ingest-lr.com',
  'cdn-staging.lr-intake.com': 'https://staging-i.lr-intake.com',
  'cdn-staging.intake-lr.com': 'https://staging-i.intake-lr.com',
  'cdn-staging.logr-ingest.com': 'https://staging-i.logr-ingest.com'
};
function setup() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    enterpriseServer = _ref.enterpriseServer,
    _ref$sdkVersion = _ref.sdkVersion,
    sdkVersion = _ref$sdkVersion === void 0 ? "8.1.0" : _ref$sdkVersion,
    opts = (0, _objectWithoutProperties2.default)(_ref, ["enterpriseServer", "sdkVersion"]);
  var scriptOrigin =  false ? 0 : 'https://cdn.logrocket.io';
  var scriptIngest;
  if (sdkVersion === 'script') {
    try {
      // eslint-disable-next-line compat/compat
      var scriptTag = document.currentScript;
      var matches = scriptTag.src.match(/^(https?:\/\/([^\\]+))\/.+$/);
      var scriptHostname = matches && matches[2];
      if (scriptHostname && CDN_SERVER_MAP[scriptHostname]) {
        scriptOrigin = matches && matches[1];
        scriptIngest = CDN_SERVER_MAP[scriptHostname];
      }
    } catch (_) {
      /* no-op */
    }
  } else {
    // NPM
    scriptOrigin =  false ? 0 : 'https://cdn.logr-ingest.com';
    scriptIngest =  false ? 0 : 'https://r.logr-ingest.com';
  }
  var sdkServer = opts.sdkServer || enterpriseServer;
  var ingestServer = opts.ingestServer || enterpriseServer || scriptIngest;
  var instance = (0, _makeLogRocket.default)(function () {
    var script = document.createElement('script');
    if (ingestServer) {
      if (typeof window.__SDKCONFIG__ === 'undefined') {
        window.__SDKCONFIG__ = {};
      }
      window.__SDKCONFIG__.serverURL = "".concat(ingestServer, "/i");
      window.__SDKCONFIG__.statsURL = "".concat(ingestServer, "/s");
    }
    if (sdkServer) {
      script.src = "".concat(sdkServer, "/logger.min.js");
    } else if (window.__SDKCONFIG__ && window.__SDKCONFIG__.loggerURL) {
      script.src = window.__SDKCONFIG__.loggerURL;
    } else if (window._lrAsyncScript) {
      script.src = window._lrAsyncScript;
    } else {
      script.src = "".concat(scriptOrigin, "/logger-1.min.js");
    }
    script.async = true;
    document.head.appendChild(script);
    script.onload = function () {
      // Brave browser: Advertises its user-agent as Chrome ##.##... then
      // loads logger.min.js, but blocks the execution of the script
      // causing _LRlogger to be undefined.  Let's make sure its there first.
      if (typeof window._LRLogger === 'function') {
        instance.onLogger(new window._LRLogger({
          sdkVersion: sdkVersion
        }));
      } else {
        console.warn('LogRocket: script execution has been blocked by a product or service.');
        instance.uninstall();
      }
    };
    script.onerror = function () {
      console.warn('LogRocket: script could not load. Check that you have a valid network connection.');
      instance.uninstall();
    };
  });
  return instance;
}
}();
__webpack_exports__ = __webpack_exports__["default"];
/******/ 	return __webpack_exports__;
/******/ })()
;
});